

# TREE_FILE_PATH: ./eslint.config.js
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'

export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
)


# TREE_FILE_PATH: ./index.html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/svg+xml" href="/icons/icon-192x192.png" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#ffffff" />
  <meta name="description" content="Point of Sale System" />
  <link rel="apple-touch-icon" href="/icons/icon-192x192.png" />
  <title>Mini POS</title>
</head>

<body>
  <div id="root"></div>
  <script type="module" src="/src/main.tsx"></script>
</body>

</html>


# TREE_FILE_PATH: ./package.json
{
  "name": "mini-pos",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@headlessui/react": "^2.2.0",
    "@heroicons/react": "^2.1.5",
    "file-saver": "^2.0.5",
    "idb": "^8.0.0",
    "lucide-react": "^0.455.0",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-router-dom": "^6.28.0",
    "workbox-background-sync": "^7.3.0",
    "workbox-precaching": "^7.3.0",
    "workbox-routing": "^7.3.0",
    "workbox-strategies": "^7.3.0"
  },
  "devDependencies": {
    "@eslint/js": "^9.13.0",
    "@types/events": "^3.0.3",
    "@types/file-saver": "^2.0.7",
    "@types/node": "^22.9.0",
    "@types/react": "^18.3.12",
    "@types/react-dom": "^18.3.1",
    "@vitejs/plugin-react": "^4.3.3",
    "autoprefixer": "^10.4.20",
    "eslint": "^9.13.0",
    "eslint-plugin-react-hooks": "^5.0.0",
    "eslint-plugin-react-refresh": "^0.4.14",
    "globals": "^15.11.0",
    "postcss": "^8.4.47",
    "tailwindcss": "^3.4.14",
    "typescript": "~5.6.2",
    "typescript-eslint": "^8.11.0",
    "vite": "^5.4.10",
    "vite-plugin-pwa": "^0.20.5"
  }
}


# TREE_FILE_PATH: ./postcss.config.js
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}


# TREE_FILE_PATH: ./README.md
# Mini POS System

A Progressive Web App (PWA) point-of-sale system with offline-first capabilities and multi-device synchronization.

## Features

- üîÑ Offline-First Architecture
- üì± Multi-Device Synchronization
- üì¶ Inventory Management
- üí∞ Sales Processing
- üèß Cash Register Control
- üìä Basic Reporting

## Tech Stack

- Frontend: React, TypeScript, Vite, TailwindCSS
- Backend: Node.js, Express, Prisma
- Database: SQLite (development), PostgreSQL (production)
- Storage: IndexedDB for local storage
- State Management: React Context

## Prerequisites

- Node.js (v14 or higher)
- npm or yarn
- Git

## Installation

1. Clone the repository:
```bash
git clone https://github.com/your-username/mini-pos.git
cd mini-pos
```

2. Install frontend dependencies:
```bash
npm install
```

3. Install backend dependencies:
```bash
cd backend
npm install
```

4. Set up the database:
```bash
npx prisma migrate reset
```

5. Create environment files:
   - Copy `.env.example` to `.env` in both root and backend directories
   - Update the environment variables as needed

## Development

1. Start the frontend development server:
```bash
npm run dev
```

2. Start the backend server:
```bash
cd backend
npm run dev
```

## Testing

```bash
# Run frontend tests
npm test

# Test sync functionality
# Open multiple browsers and use Chrome DevTools to simulate offline mode
```

## Contributing

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/AmazingFeature`)
3. Commit your changes (`git commit -m 'Add some AmazingFeature'`)
4. Push to the branch (`git push origin feature/AmazingFeature`)
5. Open a Pull Request

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## Acknowledgments

- [List any credits or inspirations]

# TREE_FILE_PATH: ./tailwind.config.js
// tailwind.config.js
module.exports = {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}

# TREE_FILE_PATH: ./tsconfig.app.json
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": [
      "ES2020",
      "DOM",
      "DOM.Iterable"
    ],
    "module": "ESNext",
    "skipLibCheck": true,
    /* Bundler mode */
    "moduleResolution": "Bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",
    /* Linting */
    "strict": true,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": [
    "src"
  ]
}

# TREE_FILE_PATH: ./tsconfig.json
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}


# TREE_FILE_PATH: ./tsconfig.node.json
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "Bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}


# TREE_FILE_PATH: ./vite.config.ts
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import { VitePWA } from 'vite-plugin-pwa'

export default defineConfig({
  plugins: [
    react(),
    VitePWA({
      registerType: 'autoUpdate',
      injectRegister: 'auto',
      filename: 'sw.js',
      manifestFilename: 'manifest.json',
      manifest: {
        name: 'Mini POS',
        short_name: 'Mini POS',
        description: 'Point of Sale System',
        theme_color: '#ffffff',
        background_color: '#ffffff',
        display: 'standalone',
        start_url: '/',
        icons: [
          {
            src: '/icons/icon-192x192.png',
            sizes: '192x192',
            type: 'image/png'
          },
          {
            src: '/icons/icon-512x512.png',
            sizes: '512x512',
            type: 'image/png'
          }
        ]
      },
      workbox: {
        globPatterns: ['**/*.{js,css,html,ico,png,svg}'],
        runtimeCaching: [
          {
            urlPattern: ({ url }) => url.pathname.startsWith('/api'),
            handler: 'NetworkFirst',
            options: {
              cacheName: 'api-cache',
              networkTimeoutSeconds: 10,
              cacheableResponse: {
                statuses: [0, 200]
              }
            }
          }
        ],
        cleanupOutdatedCaches: true
      }
    })
  ],
  server: {
    port: 5173
  },
  preview: {
    port: 5173
  }
})


# TREE_FILE_PATH: ./backend\package.json
{
  "dependencies": {
    "@prisma/client": "^5.9.1",
    "@types/bcryptjs": "^2.4.6",
    "@types/cookie-parser": "^1.4.7",
    "@types/cors": "^2.8.17",
    "@types/express": "^4.17.21",
    "@types/jsonwebtoken": "^9.0.7",
    "@types/node": "^20.17.7",
    "bcryptjs": "^2.4.3",
    "cookie-parser": "^1.4.7",
    "cors": "^2.8.5",
    "express": "^4.18.2",
    "express-rate-limit": "^7.4.1",
    "jsonwebtoken": "^9.0.2",
    "zod": "^3.23.8"
  },
  "devDependencies": {
    "prisma": "^5.9.1",
    "ts-node": "^10.9.2",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.3.3"
  },
  "scripts": {
    "dev": "ts-node-dev --respawn --transpile-only src/server.ts",
    "clean": "rm -rf dist",
    "build": "npm run clean && npx prisma generate && tsc",
    "start": "node dist/server.js",
    "seed": "ts-node prisma/seed.ts"
  },
  "prisma": {
    "seed": "ts-node prisma/seed.ts"
  }
}

# TREE_FILE_PATH: ./backend\tsconfig.json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": [
      "ES2020",
      "DOM"
    ],
    "outDir": "./dist",
    "rootDir": "./src", // Cambio importante aqu√≠
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "moduleResolution": "node",
    "sourceMap": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "resolveJsonModule": true
  },
  "include": [
    "src/**/*"
  ],
  "exclude": [
    "node_modules",
    "dist",
    "prisma"
  ]
}

# TREE_FILE_PATH: ./backend\prisma\schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Modelos existentes con algunas mejoras
model SyncOperation {
  id        String   @id @default(uuid())
  timestamp BigInt
  type      String   // 'create' | 'update' | 'delete'
  entity    String   // 'product' | 'transaction' | 'cashRegister'
  data      String   // JSON serializado
  deviceId  String
  status    String   // 'pending' | 'completed' | 'failed'
  createdAt DateTime @default(now())
  userId    String?  // Nuevo: referencia al usuario que realiz√≥ la operaci√≥n
  user      User?    @relation(fields: [userId], references: [id])
}

model Product {
    id          Int       @id @default(autoincrement())
    name        String
    supplier    Supplier? @relation(fields: [supplierId], references: [id])
    supplierId  Int?
    cost        Float
    price       Float
    stock       Int
    category    String?
    barcode     String?  @unique
    minStock    Int?
    imageUrl    String?
    createdAt   DateTime @default(now())
    updatedAt   DateTime @updatedAt
    createdBy   String    
    updatedBy   String    
    creator     User      @relation("ProductCreator", fields: [createdBy], references: [id])
    updater     User      @relation("ProductUpdater", fields: [updatedBy], references: [id])
    auditLogs   AuditLog[] // A√±adimos esta l√≠nea para la relaci√≥n bidireccional
    isActive      Boolean   @default(true)
}

model Transaction {
    id           Int      @id @default(autoincrement())
    amount       Float
    discount     Float    @default(0)
    type         String   // PaymentMethod: 'cash' | 'card' | 'transfer'
    createdAt    DateTime @default(now())
    deviceId     String
    customerName String?
    userId       String   
    user         User     @relation(fields: [userId], references: [id])
    status       String   @default("active")  // Nuevo campo: "active" | "cancelled"
}

model CashRegister {
    id            Int       @id @default(autoincrement())
    status        String    // 'open' | 'closed'
    initialAmount Float
    finalAmount   Float?
    openedAt      DateTime  @default(now())
    closedAt      DateTime?
    deviceId      String    // Este campo debe ser requerido
    userId        String    
    user          User      @relation(fields: [userId], references: [id])
}

// Nuevos modelos para autenticaci√≥n y auditor√≠a
model User {
  id            String    @id @default(uuid())
  email         String    @unique
  name          String
  passwordHash  String
  role          Role      @relation(fields: [roleId], references: [id])
  roleId        Int
  active        Boolean   @default(true)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  lastLoginAt   DateTime?

  // Relaciones
  syncOperations    SyncOperation[]
  transactions      Transaction[]
  cashRegisters     CashRegister[]
  productsCreated   Product[]      @relation("ProductCreator")
  productsUpdated   Product[]      @relation("ProductUpdater")
  auditLogs         AuditLog[]
}

model Role {
  id          Int      @id @default(autoincrement())
  name        String   @unique // 'admin' | 'user'
  permissions String[] // Array de permisos
  users       User[]
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model AuditLog {
    id        String   @id @default(uuid())
    action    String   // 'create' | 'update' | 'delete'
    entity    String   // Nombre de la entidad afectada
    entityId  String   // ID de la entidad afectada
    changes   String   // JSON con los cambios realizados
    userId    String
    user      User     @relation(fields: [userId], references: [id])
    productId Int?     // Opcional: referencia espec√≠fica a producto si aplica
    product   Product? @relation(fields: [productId], references: [id])
    createdAt DateTime @default(now())
}

model Supplier {
    id          Int       @id @default(autoincrement())
    fiscalName  String
    tradeName   String
    contact     String?
    phone       String?
    email       String?
    taxId       String?   // RIF/NIF
    address     String?
    notes       String?
    active      Boolean   @default(true)
    createdAt   DateTime  @default(now())
    updatedAt   DateTime  @updatedAt
    products    Product[]
}

# TREE_FILE_PATH: ./backend\prisma\seed.ts
// prisma/seed.ts
import { PrismaClient, Prisma } from '@prisma/client';
import bcrypt from 'bcryptjs';

declare global {
    var prisma: PrismaClient | undefined;
}

const prisma = global.prisma || new PrismaClient();

if (process.env.NODE_ENV !== 'production') {
    global.prisma = prisma;
}

const adminPermissions = [
    'manage_users',
    'manage_roles',
    'manage_products',
    'manage_inventory',
    'manage_transactions',
    'manage_cash_register',
    'view_reports',
    'export_data'
] as const;

const userPermissions = [
    'manage_products',
    'manage_inventory',
    'manage_transactions',
    'manage_cash_register',
    'view_reports'
] as const;

async function main() {
    try {
        // Crear rol de admin
        const adminRole = await prisma.$queryRaw`
            INSERT INTO "Role" (name, permissions, "createdAt", "updatedAt")
            VALUES ('admin', ${adminPermissions}::text[], NOW(), NOW())
            ON CONFLICT (name) DO UPDATE
            SET permissions = ${adminPermissions}::text[]
            RETURNING id, name;
        `;

        // Crear rol de usuario
        const userRole = await prisma.$queryRaw`
            INSERT INTO "Role" (name, permissions, "createdAt", "updatedAt")
            VALUES ('user', ${userPermissions}::text[], NOW(), NOW())
            ON CONFLICT (name) DO UPDATE
            SET permissions = ${userPermissions}::text[]
            RETURNING id, name;
        `;

        // Crear usuario admin
        const adminPassword = 'admin123';
        const hashedPassword = await bcrypt.hash(adminPassword, 10);

        await prisma.$executeRaw`
            INSERT INTO "User" (id, email, name, "passwordHash", "roleId", active, "createdAt", "updatedAt")
            VALUES (
                gen_random_uuid(),
                'admin@example.com',
                'Admin User',
                ${hashedPassword},
                (SELECT id FROM "Role" WHERE name = 'admin'),
                true,
                NOW(),
                NOW()
            )
            ON CONFLICT (email) DO NOTHING;
        `;

        console.log('Seed completed successfully');
    } catch (error) {
        console.error('Error in seed:', error);
        throw error;
    }
}

main()
    .catch((error) => {
        console.error(error);
        process.exit(1);
    })
    .finally(async () => {
        await prisma.$disconnect();
    });

# TREE_FILE_PATH: ./backend\src\config.ts
export const config = {
    nodeEnv: process.env.NODE_ENV || 'development',
    port: process.env.PORT || 3000,
    corsOrigin: process.env.CORS_ORIGIN || 'http://localhost:5173',
    databaseUrl: process.env.DATABASE_URL
};

# TREE_FILE_PATH: ./backend\src\server.ts
// backend/src/server.ts
import express from 'express';
import cors from 'cors';
import cookieParser from 'cookie-parser';
import authRoutes from './routes/authRoutes';
import syncRoutes from './routes/syncRoutes';
import { authenticate } from './middleware/auth';
import userRoutes from './routes/userRoutes';
import productRoutes from './routes/productRoutes';
import supplierRoutes from './routes/supplierRoutes';
import transactionRoutes from './routes/transactionRoutes';


const app = express();

app.use((req, res, next) => {
    console.log(`${req.method} ${req.path}`);
    next();
});

// Middlewares globales
app.use(express.json({ limit: '50mb' }));
app.use(cookieParser());

// CORS
app.use(cors({
    origin: process.env.CORS_ORIGIN || 'http://localhost:5173',
    credentials: true
}));

// Rutas de autenticaci√≥n (p√∫blicas)
app.use('/api/auth', authRoutes);

// Rutas protegidas
app.use('/api/sync', authenticate, syncRoutes);

app.use('/api/admin/users', authenticate, userRoutes);

app.use('/api/products', productRoutes);

app.use('/api/suppliers', supplierRoutes);

app.use('/api/transactions', transactionRoutes);

// Manejo de errores global
app.use((err: Error, req: express.Request, res: express.Response, next: express.NextFunction) => {
    console.error(err.stack);
    res.status(500).json({ error: 'Error interno del servidor' });
});

// Iniciar el servidor
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
    console.log(`Server running on port ${PORT}`);
});

export default app;

# TREE_FILE_PATH: ./backend\src\controllers\authController.ts
// backend/src/controllers/authController.ts
import { Request, Response } from 'express';
import { PrismaClient } from '@prisma/client';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';

const prisma = new PrismaClient();
const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key';

export const login = async (req: Request, res: Response) => {
    try {
        const { email, password } = req.body;
        console.log('Login attempt:', { email }); // Log de intento

        // Validaci√≥n b√°sica
        if (!email || !password) {
            return res.status(400).json({ error: 'Email and password are required' });
        }

        // Buscar usuario y su rol
        const user = await prisma.$queryRaw`
            SELECT u.*, r.name as role_name, r.permissions 
            FROM "User" u 
            JOIN "Role" r ON u."roleId" = r.id 
            WHERE u.email = ${email}
        `;
        console.log('User found:', user); // Log del usuario encontrado

        if (!user || !Array.isArray(user) || user.length === 0) {
            return res.status(401).json({ error: 'Invalid credentials' });
        }

        const userData = user[0];
        console.log('Comparing passwords...'); // Log antes de comparar contrase√±as

        // Verificar contrase√±a
        const validPassword = await bcrypt.compare(password, userData.passwordHash);
        console.log('Password valid:', validPassword); // Log del resultado de la comparaci√≥n

        if (!validPassword) {
            return res.status(401).json({ error: 'Invalid credentials' });
        }

        // Generar token
        const token = jwt.sign(
            {
                userId: userData.id,
                email: userData.email,
                role: userData.role_name
            },
            JWT_SECRET,
            { expiresIn: '24h' }
        );

        // Enviar respuesta
        res.json({
            token,
            user: {
                id: userData.id,
                email: userData.email,
                name: userData.name,
                role: userData.role_name
            }
        });
    } catch (error) {
        console.error('Login error:', error);
        res.status(500).json({ error: 'Server error' });
    }
};

export const validateToken = async (req: Request, res: Response) => {
    try {
        const authHeader = req.header('Authorization');
        if (!authHeader) {
            return res.status(401).json({ error: 'No token provided' });
        }

        const token = authHeader.replace('Bearer ', '');
        const decoded = jwt.verify(token, JWT_SECRET);
        res.json({ valid: true, user: decoded });
    } catch (error) {
        res.status(401).json({ valid: false, error: 'Invalid token' });
    }
};

# TREE_FILE_PATH: ./backend\src\controllers\productController.ts
// backend/src/controllers/productController.ts
import { Request, Response } from 'express';
import { PrismaClient } from '@prisma/client';
import { AuthRequest } from '../middleware/auth';

const prisma = new PrismaClient();

export const getProducts = async (req: Request, res: Response) => {
    try {
        const products = await prisma.product.findMany({
            orderBy: {
                name: 'asc'
            }
        });
        res.json(products);
    } catch (error) {
        console.error('Error fetching products:', error);
        res.status(500).json({ error: 'Error fetching products' });
    }
};

export const createProduct = async (req: Request, res: Response) => {
    try {
        const { name, price, cost, stock, category, barcode, minStock, supplierId, imageUrl } = req.body;
        console.log('Creating product with image:', imageUrl ? 'Image present' : 'No image');
        const user = (req as AuthRequest).user;

        if (!user) {
            return res.status(401).json({ error: 'User not authenticated' });
        }

        // Validaciones b√°sicas
        if (!name || price === undefined || cost === undefined || stock === undefined) {
            return res.status(400).json({ error: 'Name, price, cost and stock are required' });
        }

        // Verificar si ya existe un producto con el mismo nombre
        const existingName = await prisma.product.findFirst({
            where: { name: { equals: name, mode: 'insensitive' } }
        });

        if (existingName) {
            return res.status(400).json({ error: 'A product with this name already exists' });
        }

        // Verificar si existe un producto con el mismo c√≥digo de barras (si se proporciona)
        if (barcode) {
            const existingBarcode = await prisma.product.findFirst({
                where: { barcode }
            });

            if (existingBarcode) {
                return res.status(400).json({ error: 'A product with this barcode already exists' });
            }
        }

        const productData = {
            name,
            price: Number(price),
            cost: Number(cost),
            stock: Number(stock),
            category,
            barcode,
            minStock: minStock ? Number(minStock) : null,
            imageUrl,
            isActive: req.body.isActive ?? true,
            createdBy: user.userId,
            updatedBy: user.userId
        };

        if (supplierId) {
            Object.assign(productData, { supplierId: Number(supplierId) });
        }

        const product = await prisma.product.create({
            data: productData
        });
        console.log('Product saved with imageUrl:', product.imageUrl ? 'Yes' : 'No');

        res.status(201).json(product);
    } catch (error) {
        console.error('Error creating product:', error);
        res.status(500).json({ error: 'Error creating product' });
    }
};

export const updateProduct = async (req: Request, res: Response) => {
    try {
        const { id } = req.params;
        const { name, price, stock, category, barcode, minStock, isActive, imageUrl } = req.body;  // Agregar imageUrl
        const user = (req as AuthRequest).user;

        if (!user) {
            return res.status(401).json({ error: 'User not authenticated' });
        }

        const existingProduct = await prisma.product.findUnique({
            where: { id: Number(id) }
        });

        if (!existingProduct) {
            return res.status(404).json({ error: 'Product not found' });
        }

        const updateData = {
            name,
            price: price !== undefined ? Number(price) : undefined,
            stock: stock !== undefined ? Number(stock) : undefined,
            category,
            barcode,
            minStock: minStock ? Number(minStock) : null,
            isActive: isActive ?? existingProduct.isActive,
            imageUrl: imageUrl || undefined,  // Agregar esta l√≠nea
            updatedBy: user.userId
        };

        const product = await prisma.product.update({
            where: { id: Number(id) },
            data: updateData
        });

        res.json(product);
    } catch (error) {
        console.error('Error updating product:', error);
        res.status(500).json({ error: 'Error updating product' });
    }
};

export const toggleProductStatus = async (req: Request, res: Response) => {
    try {
        const { id } = req.params;
        console.log('Backend: Attempting to toggle product status for ID:', id);

        // Primero obtener el estado actual
        const currentProduct = await prisma.product.findUnique({
            where: { id: Number(id) }
        });
        console.log('Backend: Current product state:', currentProduct);

        if (!currentProduct) {
            return res.status(404).json({ error: 'Product not found' });
        }

        // Luego actualizar al estado opuesto
        const product = await prisma.product.update({
            where: { id: Number(id) },
            data: {
                isActive: !currentProduct.isActive,
                updatedBy: (req as AuthRequest).user!.userId
            }
        });
        console.log('Backend: Updated product state:', product);

        res.json(product);
    } catch (error) {
        console.error('Backend: Error toggling product status:', error);
        res.status(500).json({ error: 'Error toggling product status' });
    }
};

export const deleteProduct = async (req: Request, res: Response) => {
    try {
        const { id } = req.params;

        // Verificar si el producto existe
        const existingProduct = await prisma.product.findUnique({
            where: { id: Number(id) }
        });

        if (!existingProduct) {
            return res.status(404).json({ error: 'Product not found' });
        }

        await prisma.product.delete({
            where: { id: Number(id) }
        });

        res.json({ message: 'Product deleted successfully' });
    } catch (error) {
        console.error('Error deleting product:', error);
        res.status(500).json({ error: 'Error deleting product' });
    }
};

# TREE_FILE_PATH: ./backend\src\controllers\supplierController.ts
// backend/src/controllers/supplierController.ts
import { Request, Response } from 'express';
import { PrismaClient, Prisma } from '@prisma/client';
import { AuthRequest } from '../middleware/auth';

const prisma = new PrismaClient({
    log: ['query', 'info', 'warn', 'error'],
});

export const getSuppliers = async (req: Request, res: Response) => {
    try {
        const suppliers = await prisma.supplier.findMany({
            orderBy: {
                tradeName: 'asc'
            }
        });
        res.json(suppliers);
    } catch (error) {
        console.error('Error fetching suppliers:', error);
        res.status(500).json({ error: 'Error fetching suppliers' });
    }
};

export const createSupplier = async (req: Request, res: Response) => {
    try {
        const {
            fiscalName,
            tradeName,
            contact,
            phone,
            email,
            taxId,
            address,
            notes
        } = req.body;

        // Validaciones b√°sicas
        if (!fiscalName || !tradeName) {
            return res.status(400).json({
                error: 'Fiscal name and trade name are required'
            });
        }

        // Verificar si ya existe un proveedor con el mismo RIF/NIF
        if (taxId) {
            const existing = await prisma.supplier.findFirst({
                where: { taxId }
            });

            if (existing) {
                return res.status(400).json({
                    error: 'A supplier with this tax ID already exists'
                });
            }
        }

        const supplier = await prisma.supplier.create({
            data: {
                fiscalName,
                tradeName,
                contact,
                phone,
                email,
                taxId,
                address,
                notes,
                active: true
            }
        });

        res.status(201).json(supplier);
    } catch (error) {
        console.error('Error creating supplier:', error);
        res.status(500).json({ error: 'Error creating supplier' });
    }
};

export const updateSupplier = async (req: Request, res: Response) => {
    try {
        const { id } = req.params;
        const {
            fiscalName,
            tradeName,
            contact,
            phone,
            email,
            taxId,
            address,
            notes,
            active
        } = req.body;

        // Verificar si el proveedor existe
        const existing = await prisma.supplier.findUnique({
            where: { id: Number(id) }
        });

        if (!existing) {
            return res.status(404).json({ error: 'Supplier not found' });
        }

        // Verificar si el nuevo RIF/NIF ya existe
        if (taxId && taxId !== existing.taxId) {
            const taxIdExists = await prisma.supplier.findFirst({
                where: {
                    taxId,
                    id: { not: Number(id) }
                }
            });

            if (taxIdExists) {
                return res.status(400).json({
                    error: 'A supplier with this tax ID already exists'
                });
            }
        }

        const supplier = await prisma.supplier.update({
            where: { id: Number(id) },
            data: {
                fiscalName,
                tradeName,
                contact,
                phone,
                email,
                taxId,
                address,
                notes,
                active
            }
        });

        res.json(supplier);
    } catch (error) {
        console.error('Error updating supplier:', error);
        res.status(500).json({ error: 'Error updating supplier' });
    }
};

export const getActiveSuppliers = async (req: Request, res: Response) => {
    try {
        const suppliers = await prisma.supplier.findMany({
            where: {
                active: true
            },
            orderBy: {
                tradeName: 'asc'
            },
            select: {
                id: true,
                fiscalName: true,
                tradeName: true
            }
        });
        res.json(suppliers);
    } catch (error) {
        console.error('Error fetching active suppliers:', error);
        res.status(500).json({ error: 'Error fetching suppliers' });
    }
};

export const deleteSupplier = async (req: Request, res: Response) => {
    try {
        const { id } = req.params;

        // Verificar si el proveedor existe
        const existing = await prisma.supplier.findUnique({
            where: { id: Number(id) }
        });

        if (!existing) {
            return res.status(404).json({ error: 'Supplier not found' });
        }

        // Eliminar el proveedor
        await prisma.supplier.delete({
            where: { id: Number(id) }
        });

        res.json({ message: 'Supplier deleted successfully' });
    } catch (error) {
        console.error('Error deleting supplier:', error);
        res.status(500).json({ error: 'Error deleting supplier' });
    }
};

# TREE_FILE_PATH: ./backend\src\controllers\syncController.ts
import { Request, Response } from 'express';
import { PrismaClient, Product } from '@prisma/client';
import { syncService } from '../services/syncService';
import { SyncRequest, SyncResponse } from '../types/sync';
import crypto from 'crypto';

const prisma = new PrismaClient();

export async function sync(req: Request, res: Response) {
    try {
        const syncRequest = req.body as SyncRequest;
        console.log('Received sync request from device:', syncRequest.deviceId);
        console.log('Incoming operations:', syncRequest.operations);

        // Procesar operaciones entrantes
        if (syncRequest.operations.length > 0) {
            console.log('Processing incoming operations...');
            await syncService.processOperations(syncRequest.operations);
            console.log('Operations processed successfully');

            // Verificar el estado actual
            const currentProducts = await prisma.product.findMany();
            console.log('Current database state:', currentProducts);
        }

        let operations;

        // Si es una sincronizaci√≥n inicial
        if (syncRequest.lastSyncTimestamp === 0) {
            const products = await prisma.product.findMany();
            operations = products.map((product: Product) => ({
                id: `initial-${product.id}`, // ID √∫nico para operaciones iniciales
                timestamp: BigInt(Date.now()),
                type: 'create' as const,
                entity: 'product' as const,
                data: JSON.stringify(product),
                deviceId: 'server',
                status: 'completed' as const
            }));
        } else {
            // Obtener solo las operaciones nuevas desde la √∫ltima sincronizaci√≥n
            operations = await syncService.getOperationsSince(
                syncRequest.lastSyncTimestamp,
                syncRequest.deviceId
            );
        }

        const response: SyncResponse = {
            success: true,
            operations: operations.map(op => ({
                ...op,
                timestamp: Number(op.timestamp)
            })),
            lastSyncTimestamp: Date.now()
        };

        res.json(response);
    } catch (error) {
        console.error('Sync error:', error);
        const response: SyncResponse = {
            success: false,
            operations: [],
            lastSyncTimestamp: 0,
            error: 'Internal server error'
        };
        res.status(500).json(response);
    }
}

# TREE_FILE_PATH: ./backend\src\controllers\transactionController.ts
import { Request, Response } from 'express';
import { PrismaClient } from '@prisma/client';
import { AuthRequest } from '../middleware/auth';

const prisma = new PrismaClient();

export const cancelTransaction = async (req: Request, res: Response) => {
    try {
        const { id } = req.params;
        const user = (req as AuthRequest).user;

        if (!user) {
            return res.status(401).json({ error: 'User not authenticated' });
        }

        // Verificar que la transacci√≥n existe
        const transaction = await prisma.transaction.findUnique({
            where: { id: Number(id) }
        });

        if (!transaction) {
            return res.status(404).json({ error: 'Transaction not found' });
        }

        // Verificar que la transacci√≥n pertenece a este usuario
        if (transaction.userId !== user.userId) {
            return res.status(403).json({ error: 'Not authorized to cancel this transaction' });
        }

        // Actualizar el estado de la transacci√≥n
        const updatedTransaction = await prisma.transaction.update({
            where: { id: Number(id) },
            data: { status: 'cancelled' }
        });

        res.json(updatedTransaction);
    } catch (error) {
        console.error('Error cancelling transaction:', error);
        res.status(500).json({ error: 'Error cancelling transaction' });
    }
};

# TREE_FILE_PATH: ./backend\src\controllers\userController.ts
// backend/src/controllers/userController.ts
import { Request, Response } from 'express';
import { PrismaClient } from '@prisma/client';
import bcrypt from 'bcryptjs';
import { AuthRequest } from '../middleware/auth';

const prisma = new PrismaClient();

// Listar usuarios
export const getUsers = async (req: Request, res: Response) => {
    try {
        const users = await prisma.user.findMany({
            select: {
                id: true,
                email: true,
                name: true,
                active: true,
                role: {
                    select: {
                        name: true
                    }
                }
            }
        });

        const formattedUsers = users.map(user => ({
            id: user.id,
            email: user.email,
            name: user.name,
            active: user.active,
            role: user.role.name
        }));

        res.json(formattedUsers);
    } catch (error) {
        console.error('Error fetching users:', error);
        res.status(500).json({ error: 'Error fetching users' });
    }
};

// Crear usuario
export const createUser = async (req: Request, res: Response) => {
    try {
        const { email, name, password, roleId } = req.body;

        // Validaciones b√°sicas
        if (!email || !name || !password || !roleId) {
            return res.status(400).json({ error: 'All fields are required' });
        }

        // Verificar si el email ya existe
        const existingUser = await prisma.user.findUnique({
            where: { email }
        });

        if (existingUser) {
            return res.status(400).json({ error: 'Email already exists' });
        }

        // Hash de la contrase√±a
        const hashedPassword = await bcrypt.hash(password, 10);

        // Crear usuario
        const user = await prisma.user.create({
            data: {
                email,
                name,
                passwordHash: hashedPassword,
                roleId: parseInt(roleId),
                active: true
            },
            select: {
                id: true,
                email: true,
                name: true,
                active: true,
                role: {
                    select: {
                        name: true
                    }
                }
            }
        });

        res.status(201).json({
            id: user.id,
            email: user.email,
            name: user.name,
            active: user.active,
            role: user.role.name
        });
    } catch (error) {
        console.error('Error creating user:', error);
        res.status(500).json({ error: 'Error creating user' });
    }
};

// Actualizar estado del usuario
export const toggleUserStatus = async (req: Request, res: Response) => {
    try {
        const { id } = req.params;
        const currentUser = (req as AuthRequest).user;

        // Verificar que no sea el admin principal
        const userToToggle = await prisma.user.findUnique({
            where: { id },
            include: { role: true }
        });

        if (!userToToggle) {
            return res.status(404).json({ error: 'User not found' });
        }

        // Prevenir la desactivaci√≥n del admin master
        if (userToToggle.email === 'admin@example.com') {
            return res.status(403).json({ error: 'Cannot modify admin master account' });
        }

        const updatedUser = await prisma.user.update({
            where: { id },
            data: { active: !userToToggle.active },
            select: {
                id: true,
                email: true,
                name: true,
                active: true,
                role: {
                    select: {
                        name: true
                    }
                }
            }
        });

        res.json({
            id: updatedUser.id,
            email: updatedUser.email,
            name: updatedUser.name,
            active: updatedUser.active,
            role: updatedUser.role.name
        });
    } catch (error) {
        console.error('Error toggling user status:', error);
        res.status(500).json({ error: 'Error updating user status' });
    }
};

# TREE_FILE_PATH: ./backend\src\middleware\auth.ts
// backend/src/middleware/auth.ts
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';

const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key';

// Definir la interfaz para el payload del token
interface JWTPayload {
    userId: string;
    email: string;
    role: string;
}

// Extender Request para incluir el usuario
export interface AuthRequest extends Request {
    user?: JWTPayload;
}

export const authenticate = async (
    req: Request,
    res: Response,
    next: NextFunction
) => {
    try {
        const authHeader = req.header('Authorization');
        console.log('Auth header:', authHeader);

        if (!authHeader) {
            console.log('No authorization header present');
            return res.status(401).json({ error: 'No token provided' });
        }

        const token = authHeader.replace('Bearer ', '');
        console.log('Token extracted, attempting verification');

        const decoded = jwt.verify(token, JWT_SECRET) as JWTPayload;
        console.log('Token verified successfully');

        (req as AuthRequest).user = decoded;
        next();
    } catch (error) {
        console.log('Authentication error:', error);
        res.status(401).json({ error: 'Invalid token' });
    }
};

// Middleware simple para verificar rol
export const requireAdmin = (
    req: Request,
    res: Response,
    next: NextFunction
) => {
    const user = (req as AuthRequest).user;
    if (!user || user.role !== 'admin') {
        return res.status(403).json({ error: 'Access denied' });
    }
    next();
};

# TREE_FILE_PATH: ./backend\src\middleware\roleMiddleware.ts
// backend/src/middleware/roleMiddleware.ts
import { Request, Response, NextFunction } from 'express';
import { AuthRequest } from './auth';

export const requireRole = (roles: string[]) => {
    return (req: Request, res: Response, next: NextFunction) => {
        const user = (req as AuthRequest).user;

        if (!user || !roles.includes(user.role)) {
            return res.status(403).json({
                error: 'Access denied: insufficient permissions'
            });
        }

        next();
    };
};

# TREE_FILE_PATH: ./backend\src\routes\authRoutes.ts
// backend/src/routes/authRoutes.ts
import { Router } from 'express';
import { login, validateToken } from '../controllers/authController';
import { authenticate } from '../middleware/auth';

const router = Router();

router.post('/login', login);
router.get('/validate', authenticate, validateToken);

export default router;

# TREE_FILE_PATH: ./backend\src\routes\productRoutes.ts
// backend/src/routes/productRoutes.ts
import { Router } from 'express';
import { authenticate } from '../middleware/auth';
import { requireRole } from '../middleware/roleMiddleware';
import {
    getProducts,
    createProduct,
    updateProduct,
    deleteProduct,
    toggleProductStatus
} from '../controllers/productController';

const router = Router();

// Rutas p√∫blicas (solo obtener productos)
router.get('/', authenticate, getProducts);

// Rutas protegidas (solo admin)
router.post('/', authenticate, requireRole(['admin']), createProduct);
router.put('/:id', authenticate, requireRole(['admin']), updateProduct);
router.delete('/:id', authenticate, requireRole(['admin']), deleteProduct);

router.patch('/:id/toggle-status', authenticate, requireRole(['admin']), (req, res, next) => {
    console.log('Route hit: toggle-status');
    next();
}, toggleProductStatus);

export default router;

# TREE_FILE_PATH: ./backend\src\routes\supplierRoutes.ts
// backend/src/routes/supplierRoutes.ts
import { Router } from 'express';
import { authenticate } from '../middleware/auth';
import { requireRole } from '../middleware/roleMiddleware';
import {
    getSuppliers,
    createSupplier,
    updateSupplier,
    getActiveSuppliers
} from '../controllers/supplierController';
import { deleteSupplier } from '../controllers/supplierController';

const router = Router();

// Ruta para obtener lista simple de proveedores activos (para dropdowns)
router.get('/active', authenticate, getActiveSuppliers);

// Rutas protegidas (solo admin)
router.get('/', authenticate, requireRole(['admin']), getSuppliers);
router.post('/', authenticate, requireRole(['admin']), createSupplier);
router.put('/:id', authenticate, requireRole(['admin']), updateSupplier);
router.delete('/:id', authenticate, requireRole(['admin']), deleteSupplier);


export default router;

# TREE_FILE_PATH: ./backend\src\routes\syncRoutes.ts
import { Router } from 'express';
import cors from 'cors';
import { sync } from '../controllers/syncController';
import { config } from '../config';

const router = Router();

// Configurar CORS espec√≠ficamente para la ruta de sync
const corsOptions = {
    origin: config.corsOrigin,
    credentials: true
};

router.post('/', cors(corsOptions), sync);

export default router;

# TREE_FILE_PATH: ./backend\src\routes\transactionRoutes.ts
import { Router } from 'express';
import { authenticate } from '../middleware/auth';
import { cancelTransaction } from '../controllers/transactionController';

const router = Router();

router.put('/:id/cancel', authenticate, cancelTransaction);

export default router;

# TREE_FILE_PATH: ./backend\src\routes\userRoutes.ts
// backend/src/routes/userRoutes.ts
import { Router } from 'express';
import { getUsers, createUser, toggleUserStatus } from '../controllers/userController';
import { authenticate } from '../middleware/auth';

const router = Router();

router.get('/', authenticate, getUsers);
router.post('/', authenticate, createUser);
router.patch('/:id/toggle-status', authenticate, toggleUserStatus);

export default router;

# TREE_FILE_PATH: ./backend\src\services\syncService.ts
import { PrismaClient } from '@prisma/client';
import { SyncOperation, SyncRequest, SyncResponse } from '../types/sync';

const prisma = new PrismaClient();

class SyncService {
    async processOperations(operations: SyncRequest['operations']): Promise<void> {
        for (const operation of operations) {
            try {
                console.log(`Processing operation: ${operation.type} ${operation.entity}`, operation);

                // Verificar si la operaci√≥n ya fue procesada
                const existingOperation = await prisma.syncOperation.findUnique({
                    where: { id: operation.id }
                });

                if (existingOperation) {
                    console.log(`Operation ${operation.id} already processed, skipping`);
                    continue;
                }

                // Convertir timestamp de number a bigint
                const syncOp: SyncOperation = {
                    ...operation,
                    timestamp: BigInt(operation.timestamp)
                };

                // Primero guardar el registro de la operaci√≥n como 'pending'
                await prisma.syncOperation.create({
                    data: {
                        id: syncOp.id,
                        timestamp: syncOp.timestamp,
                        type: syncOp.type,
                        entity: syncOp.entity,
                        data: syncOp.data,
                        deviceId: syncOp.deviceId,
                        status: 'pending'
                    }
                });

                // Luego aplicar la operaci√≥n
                await this.applyOperation(syncOp);
                console.log('Operation applied successfully');

                // Actualizar el estado a 'completed'
                await prisma.syncOperation.update({
                    where: { id: syncOp.id },
                    data: { status: 'completed' }
                });

                console.log('Operation completed successfully');
            } catch (error) {
                console.error(`Error processing operation ${operation.id}:`, error);
                // Actualizar la operaci√≥n como fallida si existe
                try {
                    await prisma.syncOperation.update({
                        where: { id: operation.id },
                        data: { status: 'failed' }
                    });
                } catch {
                    // Si no existe, crearla como fallida
                    await prisma.syncOperation.create({
                        data: {
                            ...operation,
                            timestamp: BigInt(operation.timestamp),
                            status: 'failed'
                        }
                    });
                }
            }
        }
    }

    private async applyOperation(operation: SyncOperation): Promise<void> {
        const data = JSON.parse(operation.data);

        switch (operation.entity) {
            case 'product':
                await this.applyProductOperation(operation.type, data);
                break;
            case 'transaction':
                await this.applyTransactionOperation(operation.type, data);
                break;
            case 'cashRegister':
                await this.applyCashRegisterOperation(operation.type, data);
                break;
        }
    }

    private async applyProductOperation(type: string, data: any): Promise<void> {
        // Remover campos que no est√°n en el esquema
        const { lastUpdated, ...productData } = data;

        switch (type) {
            case 'create':
                await prisma.product.create({
                    data: productData
                });
                break;
            case 'update':
                await prisma.product.update({
                    where: { id: data.id },
                    data: productData
                });
                break;
            case 'delete':
                await prisma.product.delete({
                    where: { id: data.id }
                });
                break;
        }
    }

    private async applyTransactionOperation(type: string, data: any): Promise<void> {
        if (type === 'create') {
            await prisma.transaction.create({ data });
        }
    }

    private async applyCashRegisterOperation(type: string, data: any): Promise<void> {
        switch (type) {
            case 'create':
            case 'update':
                await prisma.cashRegister.upsert({
                    where: { id: data.id || -1 },
                    create: data,
                    update: data
                });
                break;
        }
    }

    async getOperationsSince(timestamp: number, deviceId: string): Promise<SyncResponse['operations']> {
        const operations = await prisma.syncOperation.findMany({
            where: {
                timestamp: { gt: BigInt(timestamp) },
                deviceId: { not: deviceId },
                status: 'completed'
            },
            orderBy: {
                timestamp: 'asc'
            }
        });

        return operations.map((op: {
            id: string;
            timestamp: bigint;
            type: string;
            entity: string;
            data: string;
            deviceId: string;
            status: string;
            createdAt: Date;
        }) => ({
            id: op.id,
            type: op.type as 'create' | 'update' | 'delete',
            entity: op.entity as 'product' | 'transaction' | 'cashRegister',
            data: op.data,
            deviceId: op.deviceId,
            status: op.status as 'pending' | 'completed' | 'failed',
            timestamp: Number(op.timestamp),
            createdAt: op.createdAt
        }));
    }
}

export const syncService = new SyncService();

# TREE_FILE_PATH: ./backend\src\types\auth.ts
// backend/src/types/auth.ts
import { z } from 'zod';

export const loginSchema = z.object({
    email: z.string().email('Email inv√°lido'),
    password: z.string().min(6, 'La contrase√±a debe tener al menos 6 caracteres')
});

export type LoginRequest = z.infer<typeof loginSchema>;

export interface JWTPayload {
    userId: string;
    email: string;
    role: string;
    permissions: string[];
}

export interface AuthenticatedRequest extends Express.Request {
    user?: JWTPayload;
}

# TREE_FILE_PATH: ./backend\src\types\sync.ts
export interface SyncOperation {
    id: string;
    timestamp: bigint;
    type: 'create' | 'update' | 'delete';
    entity: 'product' | 'transaction' | 'cashRegister';
    data: string;
    deviceId: string;
    status: 'pending' | 'completed' | 'failed';
    createdAt?: Date;
}

export interface SyncRequest {
    operations: Array<Omit<SyncOperation, 'timestamp'> & { timestamp: number }>;
    lastSyncTimestamp: number;
    deviceId: string;
}

export interface SyncResponse {
    success: boolean;
    operations: Array<Omit<SyncOperation, 'timestamp'> & { timestamp: number }>;
    lastSyncTimestamp: number;
    error?: string;
}

# TREE_FILE_PATH: ./backend\src\utils\auth.ts
// backend/src/utils/auth.ts
import jwt from 'jsonwebtoken';
import { JWTPayload } from '../types/auth';
import { config } from '../config';

const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key';
const JWT_EXPIRES_IN = '24h';

export const generateToken = (payload: JWTPayload): string => {
    return jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });
};

export const verifyToken = (token: string): JWTPayload => {
    return jwt.verify(token, JWT_SECRET) as JWTPayload;
};

export const extractTokenFromHeader = (header: string): string | null => {
    const match = header.match(/^Bearer (.+)$/);
    return match ? match[1] : null;
};

// Funci√≥n auxiliar para verificar permisos
export const hasPermission = (userPermissions: string[], requiredPermission: string): boolean => {
    return userPermissions.includes(requiredPermission);
};

# TREE_FILE_PATH: ./src\App.tsx
// src/App.tsx
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import { AuthProvider } from './context/AuthContext';
import ProtectedRoute from './components/ProtectedRoute';
import Navigation from './components/Navigation';
import UsersPage from './pages/admin/UsersPage';

// Pages
import Login from './pages/Login';
import POSPage from './pages/pos/POSPage';
import InventoryPage from './pages/inventory/InventoryPage';
import RegisterControl from './pages/register/RegisterControl';
import SuppliersPage from './pages/admin/SuppliersPage';


function App() {
  return (
    <AuthProvider>
      <Router>
        <div className="min-h-screen bg-gray-50">
          <Navigation />
          <main className="p-4">
            <Routes>
              {/* Ruta p√∫blica */}
              <Route path="/login" element={<Login />} />

              {/* Ruta por defecto - redirige a login */}
              <Route path="/" element={<Navigate to="/login" replace />} />

              {/* Rutas protegidas */}
              <Route
                path="/inventory"
                element={
                  <ProtectedRoute allowedRoles={['admin']}>
                    <InventoryPage />
                  </ProtectedRoute>
                } />

              <Route
                path="/admin/suppliers"
                element={
                  <ProtectedRoute allowedRoles={['admin']}>
                    <SuppliersPage />
                  </ProtectedRoute>
                }
              />

              <Route
                path="/pos"
                element={
                  <ProtectedRoute>
                    <POSPage />
                  </ProtectedRoute>
                }
              />

              <Route
                path="/register"
                element={
                  <ProtectedRoute>
                    <RegisterControl />
                  </ProtectedRoute>
                }
              />

              <Route
                path="/admin/users"
                element={
                  <ProtectedRoute allowedRoles={['admin']}>
                    <UsersPage />
                  </ProtectedRoute>
                }
              />

              {/* Ruta para manejar URLs no encontradas */}
              <Route path="*" element={<Navigate to="/" replace />} />
            </Routes>
          </main>
        </div>
      </Router>
    </AuthProvider>
  );
}

export default App;

# TREE_FILE_PATH: ./src\config.ts
export const config = {
    apiUrl: import.meta.env.VITE_API_URL || 'http://localhost:3000/api'
};

# TREE_FILE_PATH: ./src\index.css
@tailwind base;
@tailwind components;
@tailwind utilities;

# TREE_FILE_PATH: ./src\main.tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './index.css';
import { initializeApp } from './lib/init';

// Registrar Service Worker
const registerServiceWorker = async () => {
  if ('serviceWorker' in navigator) {
    try {
      const registration = await navigator.serviceWorker.register('/sw-custom.ts', {
        type: 'module',
      });
      console.log('Service Worker registered successfully:', registration);
    } catch (error) {
      console.error('Service Worker registration failed:', error);
    }
  }
};

// Inicializar la aplicaci√≥n antes de renderizar
initializeApp()
  .then(() => {
    // Renderizar la aplicaci√≥n
    ReactDOM.createRoot(document.getElementById('root')!).render(
      <React.StrictMode>
        <App />
      </React.StrictMode>
    );
  })
  .catch(error => {
    console.error('Failed to initialize app:', error);
    // Aqu√≠ podr√≠as mostrar un mensaje de error al usuario
  });

# TREE_FILE_PATH: ./src\sw-custom.ts
/// <reference lib="webworker" />

import { precacheAndRoute } from 'workbox-precaching'
import { registerRoute } from 'workbox-routing'
import { NetworkFirst, NetworkOnly } from 'workbox-strategies'
import { Queue } from 'workbox-background-sync'

declare const self: ServiceWorkerGlobalScope;

// Precache todos los assets est√°ticos
precacheAndRoute(self.__WB_MANIFEST)

// Cola para sincronizaci√≥n en segundo plano
const syncQueue = new Queue('syncQueue')

// Ruta para las llamadas de API
registerRoute(
    /^https:\/\/api\.*/i,
    async (options) => {
        try {
            const strategy = new NetworkOnly()
            return await strategy.handle(options)
        } catch (error) {
            await syncQueue.pushRequest({ request: options.request })
            throw error
        }
    },
    'POST'
)

// Ruta para obtener datos
registerRoute(
    /^https:\/\/api\.*/i,
    new NetworkFirst({
        cacheName: 'api-cache',
        networkTimeoutSeconds: 10
    }),
    'GET'
)

# TREE_FILE_PATH: ./src\vite-env.d.ts
/// <reference types="vite/client" />


# TREE_FILE_PATH: ./src\components\Navigation.tsx
// src/components/Navigation.tsx
import React from 'react';
import { Link, useLocation } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';

const Navigation = () => {
    const { user, logout } = useAuth();
    const location = useLocation();

    if (!user) return null;

    const isActive = (path: string) => location.pathname === path;

    return (
        <nav className="bg-white shadow-lg">
            <div className="max-w-7xl mx-auto px-4">
                <div className="flex justify-between h-16">
                    <div className="flex space-x-4 items-center">
                        <Link
                            to="/pos"
                            className={`px-3 py-2 rounded-md text-sm font-medium ${isActive('/pos')
                                ? 'bg-blue-500 text-white'
                                : 'text-gray-700 hover:bg-blue-50'
                                }`}
                        >
                            POS
                        </Link>

                        {user.role === 'admin' && (
                            <Link
                                to="/inventory"
                                className={`px-3 py-2 rounded-md text-sm font-medium ${isActive('/inventory')
                                    ? 'bg-blue-500 text-white'
                                    : 'text-gray-700 hover:bg-blue-50'
                                    }`}
                            >
                                Inventory
                            </Link>
                        )}

                        {user.role === 'admin' && (
                            <Link
                                to="/admin/suppliers"
                                className={`px-3 py-2 rounded-md text-sm font-medium ${isActive('/admin/suppliers')
                                    ? 'bg-blue-500 text-white'
                                    : 'text-gray-700 hover:bg-blue-50'
                                    }`}
                            >
                                Suppliers
                            </Link>
                        )}

                        <Link
                            to="/register"
                            className={`px-3 py-2 rounded-md text-sm font-medium ${isActive('/register')
                                ? 'bg-blue-500 text-white'
                                : 'text-gray-700 hover:bg-blue-50'
                                }`}
                        >
                            Register
                        </Link>

                        {user.role === 'admin' && (
                            <Link
                                to="/admin/users"
                                className={`px-3 py-2 rounded-md text-sm font-medium ${isActive('/admin/users')
                                    ? 'bg-blue-500 text-white'
                                    : 'text-gray-700 hover:bg-blue-50'
                                    }`}
                            >
                                Users
                            </Link>
                        )}
                    </div>

                    <div className="flex items-center space-x-4">
                        <span className="text-sm text-gray-700">
                            {user.name} ({user.role})
                        </span>
                        <button
                            onClick={logout}
                            className="px-3 py-2 rounded-md text-sm font-medium text-red-600 hover:bg-red-50"
                        >
                            Logout
                        </button>
                    </div>
                </div>
            </div>
        </nav>
    );
};

export default Navigation;

# TREE_FILE_PATH: ./src\components\ProtectedRoute.tsx
// src/components/ProtectedRoute.tsx
import React from 'react';
import { Navigate } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';

interface ProtectedRouteProps {
    children: React.ReactNode;
    allowedRoles?: string[];
}

const ProtectedRoute: React.FC<ProtectedRouteProps> = ({
    children,
    allowedRoles = []
}) => {
    const { user, isLoading } = useAuth();

    if (isLoading) {
        return <div>Loading...</div>;
    }

    if (!user) {
        return <Navigate to="/login" />;
    }

    // Si hay roles permitidos y el usuario no tiene el rol adecuado
    if (allowedRoles.length > 0 && !allowedRoles.includes(user.role)) {
        // Redirigir a POS si no tiene acceso
        return <Navigate to="/pos" />;
    }

    return <>{children}</>;
};

export default ProtectedRoute;

# TREE_FILE_PATH: ./src\components\admin\UserForm.tsx
// src/components/admin/UserForm.tsx
import React, { useState } from 'react';

interface UserFormProps {
    onSubmit: (userData: UserFormData) => Promise<void>;
    onCancel: () => void;
}

interface UserFormData {
    name: string;
    email: string;
    password: string;
    roleId: string;
}

const UserForm: React.FC<UserFormProps> = ({ onSubmit, onCancel }) => {
    const [formData, setFormData] = useState<UserFormData>({
        name: '',
        email: '',
        password: '',
        roleId: '2'  // Por defecto, rol de usuario normal
    });
    const [error, setError] = useState<string | null>(null);
    const [isLoading, setIsLoading] = useState(false);

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        setError(null);
        setIsLoading(true);

        try {
            await onSubmit(formData);
        } catch (err) {
            setError(err instanceof Error ? err.message : 'Error creating user');
        } finally {
            setIsLoading(false);
        }
    };

    const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>) => {
        const { name, value } = e.target;
        setFormData(prev => ({
            ...prev,
            [name]: value
        }));
    };

    return (
        <form onSubmit={handleSubmit} className="space-y-4">
            <div>
                <label className="block text-sm font-medium text-gray-700">
                    Name
                </label>
                <input
                    type="text"
                    name="name"
                    value={formData.name}
                    onChange={handleChange}
                    required
                    className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
                />
            </div>

            <div>
                <label className="block text-sm font-medium text-gray-700">
                    Email
                </label>
                <input
                    type="email"
                    name="email"
                    value={formData.email}
                    onChange={handleChange}
                    required
                    className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
                />
            </div>

            <div>
                <label className="block text-sm font-medium text-gray-700">
                    Password
                </label>
                <input
                    type="password"
                    name="password"
                    value={formData.password}
                    onChange={handleChange}
                    required
                    minLength={6}
                    className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
                />
            </div>

            <div>
                <label className="block text-sm font-medium text-gray-700">
                    Role
                </label>
                <select
                    name="roleId"
                    value={formData.roleId}
                    onChange={handleChange}
                    className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
                >
                    <option value="2">User</option>
                    <option value="1">Admin</option>
                </select>
            </div>

            {error && (
                <div className="text-red-600 text-sm">{error}</div>
            )}

            <div className="flex gap-3">
                <button
                    type="submit"
                    disabled={isLoading}
                    className="flex-1 bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700 disabled:opacity-50"
                >
                    {isLoading ? 'Creating...' : 'Create User'}
                </button>
                <button
                    type="button"
                    onClick={onCancel}
                    className="flex-1 bg-gray-100 text-gray-700 py-2 px-4 rounded-md hover:bg-gray-200"
                >
                    Cancel
                </button>
            </div>
        </form>
    );
};

export default UserForm;

# TREE_FILE_PATH: ./src\components\common\SearchBar.tsx
// src/components/common/SearchBar.tsx
import React from 'react';
import { MagnifyingGlassIcon } from '@heroicons/react/24/outline';

interface SearchBarProps {
    placeholder?: string;
    value: string;
    onChange: (value: string) => void;
}

const SearchBar: React.FC<SearchBarProps> = ({
    placeholder = "Search...",
    value,
    onChange
}) => {
    return (
        <div className="relative">
            <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                <MagnifyingGlassIcon className="h-5 w-5 text-gray-400" />
            </div>
            <input
                type="text"
                className="block w-full pl-10 pr-3 py-2 border border-gray-300 rounded-md leading-5 bg-white placeholder-gray-500 focus:outline-none focus:placeholder-gray-400 focus:ring-1 focus:ring-blue-500 focus:border-blue-500 sm:text-sm"
                placeholder={placeholder}
                value={value}
                onChange={(e) => onChange(e.target.value)}
            />
        </div>
    );
};

export default SearchBar;

# TREE_FILE_PATH: ./src\components\inventory\ProductForm.tsx
// src/components/inventory/ProductForm.tsx
import React, { useState, useEffect, useRef } from 'react';
import { Product } from '../../types';
import { productOperations } from '../../lib/database';
import { config } from '../../config';


type ProductFormData = Omit<Product, 'id' | 'createdAt' | 'updatedAt'>;

interface Supplier {
    id: number;
    tradeName: string;
}

interface ProductFormProps {
    onSubmit: () => void;
    initialProduct?: Product;
    onCancel: () => void;
}

const CATEGORIES = ['Wines', 'Beers', 'Spirits', 'Food', 'Others'];

const ProductForm: React.FC<ProductFormProps> = ({
    onSubmit,
    initialProduct,
    onCancel
}) => {
    const [formData, setFormData] = useState({
        name: initialProduct?.name || '',
        barcode: initialProduct?.barcode || '',
        category: initialProduct?.category || CATEGORIES[0],
        supplierId: initialProduct?.supplierId?.toString() || '',
        cost: initialProduct?.cost?.toString() || '',
        price: initialProduct?.price?.toString() || '',
        stock: initialProduct?.stock?.toString() || '',
        minStock: initialProduct?.minStock?.toString() || '',
        imageUrl: initialProduct?.imageUrl || '',
        isActive: initialProduct?.isActive ?? true
    });
    const [suppliers, setSuppliers] = useState<{ id: number, tradeName: string }[]>([]);
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState<string | null>(null);

    const [showCamera, setShowCamera] = useState(false);
    const videoRef = useRef<HTMLVideoElement>(null);
    const streamRef = useRef<MediaStream | null>(null);
    const [stream, setStream] = useState<MediaStream | null>(null);

    useEffect(() => {
        const loadSuppliers = async () => {
            try {
                const response = await fetch(`${config.apiUrl}/suppliers/active`, {
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    }
                });

                if (!response.ok) {
                    throw new Error('Failed to load suppliers');
                }

                const data = await response.json();
                setSuppliers(data);
            } catch (err) {
                console.error('Error loading suppliers:', err);
            }
        };

        loadSuppliers();
    }, []);

    const handleCameraClick = async () => {
        try {
            console.log('Requesting camera access...');
            const newStream = await navigator.mediaDevices.getUserMedia({
                video: {
                    facingMode: 'environment',
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                }
            });
            console.log('Camera access granted, stream:', newStream);
            setStream(newStream);
            setShowCamera(true);
        } catch (err: unknown) {
            console.error('Detailed camera error:', err);
            setError(`Could not access camera: ${err instanceof Error ? err.message : 'Unknown error'}`);
        }
    };

    // A√±adir este useEffect para manejar la inicializaci√≥n del video
    useEffect(() => {
        if (showCamera && stream && videoRef.current) {
            console.log('Initializing video with stream');
            videoRef.current.srcObject = stream;
            videoRef.current.play()
                .then(() => console.log('Video playing'))
                .catch(err => console.error('Error playing video:', err));
        }

        // Cleanup
        return () => {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }
        };
    }, [showCamera, stream]);

    const handleCapture = () => {
        const video = videoRef.current;
        if (!video || !video.videoWidth) {
            setError('Video stream not ready');
            return;
        }

        try {
            const canvas = document.createElement('canvas');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;

            const ctx = canvas.getContext('2d');
            if (!ctx) {
                setError('Could not initialize canvas');
                return;
            }

            // Dibujar el frame actual del video
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

            const imageUrl = canvas.toDataURL('image/jpeg', 0.8);
            setFormData(prev => ({ ...prev, imageUrl }));

            // Limpiar
            if (streamRef.current) {
                streamRef.current.getTracks().forEach(track => track.stop());
                streamRef.current = null;
            }
            setShowCamera(false);
        } catch (err) {
            console.error('Error capturing image:', err);
            setError('Failed to capture image');
        }
    };

    // Agregar este useEffect para limpiar el stream cuando se cierra el modal
    useEffect(() => {
        return () => {
            if (streamRef.current) {
                streamRef.current.getTracks().forEach(track => track.stop());
            }
        };
    }, []);

    const loadSuppliers = async () => {
        try {
            const response = await fetch(`${config.apiUrl}/suppliers/active`, {
                headers: {
                    'Authorization': `Bearer ${localStorage.getItem('token')}`
                }
            });

            if (!response.ok) {
                throw new Error('Failed to load suppliers');
            }

            const data = await response.json();
            setSuppliers(data);
        } catch (err) {
            setError('Error loading suppliers');
        }
    };

    const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>) => {
        const { name, value, type } = e.target;
        const newValue = type === 'checkbox'
            ? (e.target as HTMLInputElement).checked
            : value;

        console.log(`Changing ${name} to:`, newValue); // Para debug

        setFormData(prev => ({
            ...prev,
            [name]: newValue
        }));
    };

    const handleImageChange = async (e: React.ChangeEvent<HTMLInputElement>) => {
        const file = e.target.files?.[0];
        if (file) {
            try {
                console.log('File selected:', file);
                const reader = new FileReader();
                reader.onloadend = () => {
                    console.log('Image converted to base64');
                    setFormData(prev => ({
                        ...prev,
                        imageUrl: reader.result as string
                    }));
                    console.log('Image URL length:', (reader.result as string).length);
                };
                reader.readAsDataURL(file);
            } catch (err) {
                console.error('Error processing image:', err);
                setError('Error processing image');
            }
        }
    };

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        setError(null);
        setIsLoading(true);

        try {
            const productData: ProductFormData = {
                name: formData.name.trim(),
                barcode: formData.barcode || undefined,
                category: formData.category,
                supplierId: formData.supplierId ? parseInt(formData.supplierId) : undefined,
                cost: parseFloat(formData.cost),
                price: parseFloat(formData.price),
                stock: parseInt(formData.stock),
                minStock: formData.minStock ? parseInt(formData.minStock) : undefined,
                imageUrl: formData.imageUrl || undefined,
                isActive: formData.isActive
            };

            if (initialProduct) {
                await productOperations.update(initialProduct.id, productData);
            } else {
                // Verificar duplicados antes de crear
                const allProducts = await productOperations.getAll();

                // Verificar nombre duplicado
                const duplicateName = allProducts.find(
                    p => p.name.toLowerCase() === productData.name.toLowerCase()
                );
                if (duplicateName) {
                    throw new Error('A product with this name already exists');
                }

                // Verificar c√≥digo de barras duplicado
                if (productData.barcode) {
                    const duplicateBarcode = allProducts.find(
                        p => p.barcode === productData.barcode
                    );
                    if (duplicateBarcode) {
                        throw new Error('A product with this barcode already exists');
                    }
                }

                await productOperations.create(productData);
            }

            onSubmit();
        } catch (err) {
            setError(err instanceof Error ? err.message : 'Error saving product');
        } finally {
            setIsLoading(false);
        }
    };

    return (
        <form onSubmit={handleSubmit} className="space-y-4">
            <div>
                <label className="block text-sm font-medium text-gray-700">Name</label>
                <input
                    type="text"
                    name="name"
                    value={formData.name}
                    onChange={handleChange}
                    required
                    maxLength={100}
                    className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
                />
            </div>

            <div>
                <label className="block text-sm font-medium text-gray-700">Barcode</label>
                <input
                    type="text"
                    name="barcode"
                    value={formData.barcode}
                    onChange={handleChange}
                    className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
                />
            </div>

            <div>
                <label className="block text-sm font-medium text-gray-700">Category</label>
                <select
                    name="category"
                    value={formData.category}
                    onChange={handleChange}
                    className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
                >
                    {CATEGORIES.map(category => (
                        <option key={category} value={category}>{category}</option>
                    ))}
                </select>
            </div>

            <div>
                <label className="block text-sm font-medium text-gray-700">Supplier</label>
                <select
                    name="supplierId"
                    value={formData.supplierId || ''}
                    onChange={handleChange}
                    className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
                >
                    <option value="">Select a supplier</option>
                    {suppliers.map(supplier => (
                        <option key={supplier.id} value={supplier.id}>
                            {supplier.tradeName}
                        </option>
                    ))}
                </select>
            </div>

            <div>
                <label className="block text-sm font-medium text-gray-700">Cost</label>
                <input
                    type="number"
                    name="cost"
                    value={formData.cost}
                    onChange={handleChange}
                    required
                    step="0.01"
                    min="0"
                    className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
                />
            </div>

            <div>
                <label className="block text-sm font-medium text-gray-700">Price</label>
                <input
                    type="number"
                    name="price"
                    value={formData.price}
                    onChange={handleChange}
                    required
                    step="0.01"
                    min="0"
                    className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
                />
            </div>

            <div>
                <label className="block text-sm font-medium text-gray-700">Stock</label>
                <input
                    type="number"
                    name="stock"
                    value={formData.stock}
                    onChange={handleChange}
                    required
                    min="0"
                    className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
                />
            </div>

            <div>
                <label className="block text-sm font-medium text-gray-700">
                    Minimum Stock Alert
                </label>
                <input
                    type="number"
                    name="minStock"
                    value={formData.minStock}
                    onChange={handleChange}
                    min="0"
                    className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
                />
            </div>

            <div className="flex items-center">
                <input
                    type="checkbox"
                    name="isActive"
                    checked={formData.isActive}
                    onChange={handleChange}
                    className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
                />
                <label className="ml-2 block text-sm text-gray-700">
                    Active
                </label>
            </div>

            <div>
                <label className="block text-sm font-medium text-gray-700">Image</label>
                <div className="mt-1 flex items-center gap-4">
                    <div className="flex-1">
                        <input
                            type="file"
                            accept="image/*"
                            onChange={handleImageChange}
                            className="mt-1 block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100"
                        />
                    </div>
                    <button
                        type="button"
                        onClick={handleCameraClick}
                        className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700"
                    >
                        Take Photo
                    </button>
                </div>
                {showCamera && (
                    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
                        <div className="bg-white rounded-lg p-6 max-w-2xl w-full">
                            <div className="flex justify-between items-center mb-4">
                                <h2 className="text-xl font-bold">Take Photo</h2>
                                <button
                                    type="button"
                                    onClick={() => setShowCamera(false)}
                                    className="text-gray-500 hover:text-gray-700"
                                >
                                    √ó
                                </button>
                            </div>
                            <div className="relative aspect-video mb-4">
                                <video
                                    ref={videoRef}
                                    className="w-full h-full rounded-lg object-cover bg-black"
                                    autoPlay
                                    playsInline
                                    onError={(e) => {
                                        console.error('Video error:', e);
                                        setError('Error initializing video');
                                    }}
                                />
                                {(!videoRef.current?.srcObject && !stream) && (
                                    <div className="absolute inset-0 flex items-center justify-center bg-gray-100">
                                        Initializing camera...
                                    </div>
                                )}
                            </div>
                            <div className="flex justify-end gap-3">
                                <button
                                    type="button"
                                    onClick={handleCapture}
                                    className="px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700"
                                >
                                    Capture
                                </button>
                                <button
                                    type="button"
                                    onClick={() => setShowCamera(false)}
                                    className="px-4 py-2 bg-gray-100 text-gray-700 rounded-md hover:bg-gray-200"
                                >
                                    Cancel
                                </button>
                            </div>
                        </div>
                    </div>
                )}
                {formData.imageUrl && (
                    <img
                        src={formData.imageUrl}
                        alt="Preview"
                        className="mt-2 h-32 w-32 object-cover rounded-md"
                    />
                )}
            </div>

            {error && (
                <div className="text-red-600 text-sm">{error}</div>
            )}

            <div className="flex gap-3">
                <button
                    type="submit"
                    disabled={isLoading}
                    className="flex-1 bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700 disabled:opacity-50"
                >
                    {isLoading ? 'Saving...' : initialProduct ? 'Update' : 'Add Product'}
                </button>
                <button
                    type="button"
                    onClick={onCancel}
                    className="flex-1 bg-gray-100 text-gray-700 py-2 px-4 rounded-md hover:bg-gray-200"
                >
                    Cancel
                </button>
            </div>
        </form>
    );
};

export default ProductForm;

# TREE_FILE_PATH: ./src\components\pos\Cart.tsx
// src/components/pos/Cart.tsx
import { useState } from 'react';
import { Product } from '../../types';


interface CartItem {
    product: Product;
    quantity: number;
}

interface CartProps {
    items: CartItem[];
    onUpdateQuantity: (productId: number, quantity: number) => void;
    onRemoveItem: (productId: number) => void;
    onCheckout: (discount?: number) => void;
    onClearCart: () => void;
    discount: number;              // Nuevo
    onDiscountChange: (value: number) => void;  // Nuevo
}

const Cart: React.FC<CartProps> = ({
    items,
    onUpdateQuantity,
    onRemoveItem,
    onCheckout,
    onClearCart,
    discount,
    onDiscountChange
}) => {

    const subtotal = items.reduce(
        (sum, item) => sum + item.product.price * item.quantity,
        0
    );
    const total = Math.max(0, subtotal - discount);

    if (items.length === 0) {
        return (
            <div className="h-full flex flex-col items-center justify-center p-4 text-gray-500">
                <p>Cart is empty</p>
            </div>
        );
    }

    return (
        <div className="h-full flex flex-col bg-white rounded-lg shadow">
            <div className="p-4 border-b">
                <div className="flex justify-between items-center">
                    <h2 className="text-lg font-semibold">Current Order</h2>
                    <button
                        onClick={onClearCart}
                        className="text-red-600 hover:text-red-800 text-sm"
                    >
                        Clear Cart
                    </button>
                </div>
            </div>

            <div className="flex-1 overflow-auto">
                {items.map((item) => (
                    <div
                        key={item.product.id}
                        className="p-4 border-b flex justify-between items-center"
                    >
                        <div className="flex-1">
                            <h3 className="font-medium">{item.product.name}</h3>
                            <p className="text-sm text-gray-500">
                                ${item.product.price.toFixed(2)} each
                            </p>
                        </div>

                        <div className="flex items-center gap-2">
                            <button
                                onClick={() => onUpdateQuantity(item.product.id, item.quantity - 1)}
                                className="w-8 h-8 flex items-center justify-center rounded-full border border-gray-300 hover:bg-gray-100"
                            >
                                -
                            </button>
                            <span className="w-8 text-center">{item.quantity}</span>
                            <button
                                onClick={() => onUpdateQuantity(item.product.id, item.quantity + 1)}
                                className="w-8 h-8 flex items-center justify-center rounded-full border border-gray-300 hover:bg-gray-100"
                            >
                                +
                            </button>
                            <button
                                onClick={() => onRemoveItem(item.product.id)}
                                className="ml-2 text-red-600 hover:text-red-800"
                            >
                                √ó
                            </button>
                        </div>
                    </div>
                ))}
            </div>

            <div className="p-4 border-t mt-auto bg-gray-50">
                <div className="mb-4">
                    <div className="flex justify-between mb-2">
                        <span className="font-medium">Subtotal:</span>
                        <span>${subtotal.toFixed(2)}</span>
                    </div>
                    {/* Agregar aqu√≠ el input de descuento */}
                    <div className="flex items-center gap-2 mb-2">
                        <span className="font-medium">Discount:</span>
                        <input
                            type="number"
                            min="0"
                            max={subtotal}
                            value={discount}
                            onChange={(e) => onDiscountChange(Math.min(subtotal, Math.max(0, parseFloat(e.target.value) || 0)))}
                            className="w-20 px-2 py-1 border rounded-md"
                        />
                    </div>
                    <div className="flex justify-between text-lg font-bold">
                        <span>Total:</span>
                        <span>${total.toFixed(2)}</span>
                    </div>
                </div>

                <button
                    onClick={() => onCheckout(discount)}
                    className="w-full py-3 bg-green-600 text-white rounded-lg hover:bg-green-700 font-medium"
                >
                    Complete Sale (${total.toFixed(2)})
                </button>
            </div>
        </div>
    );
};

export default Cart;

# TREE_FILE_PATH: ./src\components\pos\CheckoutModal.tsx
// src/components/pos/CheckoutModal.tsx
import React, { useState } from 'react';
import { PaymentMethod } from '../../types';

interface CheckoutModalProps {
    total: number;
    discount: number;
    onComplete: (paymentMethod: PaymentMethod, customerName: string) => void;
    onCancel: () => void;
}

const PAYMENT_METHODS: PaymentMethod[] = ['cash', 'card', 'transfer'];

const CheckoutModal: React.FC<CheckoutModalProps> = ({
    total,
    discount,
    onComplete,
    onCancel
}) => {
    const [paymentMethod, setPaymentMethod] = useState<PaymentMethod>('cash');
    const [customerName, setCustomerName] = useState('');

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        onComplete(paymentMethod, customerName);
    };

    return (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4">
            <div className="bg-white rounded-lg p-6 max-w-md w-full">
                <h2 className="text-xl font-bold mb-4">Complete Sale</h2>

                <form onSubmit={handleSubmit} className="space-y-4">
                    <div>
                        <label className="block text-sm font-medium text-gray-700 mb-2">
                            Amount Details
                        </label>
                        <div className="text-3xl font-bold space-y-2">
                            <div className="text-lg text-gray-600">
                                Subtotal: ${(total + discount).toFixed(2)}
                            </div>
                            {discount > 0 && (
                                <div className="text-lg text-red-600">
                                    Discount: -${discount.toFixed(2)}
                                </div>
                            )}
                            <div className="text-green-600">
                                Total: ${total.toFixed(2)}
                            </div>
                        </div>
                    </div>

                    <div>
                        <label className="block text-sm font-medium text-gray-700 mb-2">
                            Total Amount
                        </label>
                        <div className="text-3xl font-bold text-green-600">
                            ${total.toFixed(2)}
                        </div>
                    </div>

                    <div>
                        <label className="block text-sm font-medium text-gray-700 mb-2">
                            Payment Method
                        </label>
                        <div className="space-y-2">
                            {PAYMENT_METHODS.map((method) => (
                                <label key={method} className="flex items-center">
                                    <input
                                        type="radio"
                                        name="paymentMethod"
                                        value={method}
                                        checked={paymentMethod === method}
                                        onChange={(e) => setPaymentMethod(e.target.value as PaymentMethod)}
                                        className="focus:ring-blue-500 h-4 w-4 text-blue-600 border-gray-300"
                                    />
                                    <span className="ml-2 capitalize">{method}</span>
                                </label>
                            ))}
                        </div>
                    </div>

                    <div>
                        <label className="block text-sm font-medium text-gray-700 mb-2">
                            Customer Name (optional)
                        </label>
                        <input
                            type="text"
                            value={customerName}
                            onChange={(e) => setCustomerName(e.target.value)}
                            className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
                        />
                    </div>

                    <div className="flex gap-3 pt-4">
                        <button
                            type="submit"
                            className="flex-1 bg-green-600 text-white py-2 px-4 rounded-md hover:bg-green-700"
                        >
                            Complete
                        </button>
                        <button
                            type="button"
                            onClick={onCancel}
                            className="flex-1 bg-gray-100 text-gray-700 py-2 px-4 rounded-md hover:bg-gray-200"
                        >
                            Cancel
                        </button>
                    </div>
                </form>
            </div>
        </div>
    );
};

export default CheckoutModal;

# TREE_FILE_PATH: ./src\components\pos\ProductsGrid.tsx
// src/components/pos/ProductsGrid.tsx
import React from 'react';
import { Product } from '../../types';

interface ProductsGridProps {
    products: Product[];
    onProductSelect: (product: Product) => void;
    selectedCategory: string | null;
}

const ProductsGrid: React.FC<ProductsGridProps> = ({
    products,
    onProductSelect,
    selectedCategory,
}) => {
    const filteredProducts = selectedCategory
        ? products.filter(p => p.category === selectedCategory)
        : products;

    return (
        <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
            {filteredProducts.map((product) => (
                <button
                    key={product.id}
                    onClick={() => onProductSelect(product)}
                    disabled={product.stock <= 0}
                    className={`
            p-4 rounded-lg border text-left
            ${product.stock > 0
                            ? 'hover:bg-blue-50 border-blue-200'
                            : 'opacity-50 cursor-not-allowed border-gray-200'
                        }
          `}
                >
                    <div className="aspect-square w-full bg-gray-100 rounded-md mb-2">
                        {product.imageUrl ? (
                            <img
                                src={product.imageUrl}
                                alt={product.name}
                                className="w-full h-full object-cover rounded-md"
                            />
                        ) : (
                            <div className="w-full h-full flex items-center justify-center text-gray-400">
                                No image
                            </div>
                        )}
                    </div>

                    <div className="mt-2">
                        <h3 className="font-medium text-gray-900 truncate">
                            {product.name}
                        </h3>
                        <p className="text-green-600 font-medium">
                            ${product.price.toFixed(2)}
                        </p>
                        <p className="text-sm text-gray-500">
                            Stock: {product.stock}
                        </p>
                    </div>
                </button>
            ))}
        </div>
    );
};

export default ProductsGrid;

# TREE_FILE_PATH: ./src\components\register\SalesSummary.tsx
import React from 'react';
import { Transaction, PaymentMethod, CashRegister } from '../../types';

interface SalesSummaryProps {
    transactions: Transaction[];
    initialAmount: number;
    currentRegister: CashRegister;
    onCancelTransaction: (transactionId: number) => Promise<void>;
}

const SalesSummary: React.FC<SalesSummaryProps> = ({
    transactions,
    initialAmount,
    currentRegister,
    onCancelTransaction
}) => {
    const activeTransactions = transactions.filter(t => t.status === 'active');

    const totalSales = activeTransactions.reduce((sum, t) => sum + t.amount, 0);
    const totalDiscounts = activeTransactions.reduce((sum, t) => sum + t.discount, 0);
    const salesByMethod = activeTransactions.reduce((acc, t) => ({
        ...acc,
        [t.type]: (acc[t.type] || 0) + t.amount
    }), {} as Record<PaymentMethod, number>);

    return (
        <div className="bg-white rounded-lg shadow p-6 space-y-6">
            <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
                <div className="bg-blue-50 p-4 rounded-lg">
                    <h3 className="text-sm font-medium text-blue-800">Initial Amount</h3>
                    <p className="text-2xl font-bold text-blue-900">
                        ${initialAmount.toFixed(2)}
                    </p>
                </div>
                <div className="bg-green-50 p-4 rounded-lg">
                    <h3 className="text-sm font-medium text-green-800">Total Sales</h3>
                    <p className="text-2xl font-bold text-green-900">
                        ${totalSales.toFixed(2)}
                    </p>
                </div>
                <div className="bg-red-50 p-4 rounded-lg">
                    <h3 className="text-sm font-medium text-red-800">Total Discounts</h3>
                    <p className="text-2xl font-bold text-red-900">
                        ${totalDiscounts.toFixed(2)}
                    </p>
                </div>
                <div className="bg-purple-50 p-4 rounded-lg">
                    <h3 className="text-sm font-medium text-purple-800">Expected in Register</h3>
                    <p className="text-2xl font-bold text-purple-900">
                        ${(initialAmount + totalSales).toFixed(2)}
                    </p>
                </div>
            </div>

            <div>
                <h3 className="text-lg font-medium mb-3">Sales by Payment Method</h3>
                <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                    {(['cash', 'card', 'transfer'] as PaymentMethod[]).map(method => (
                        <div key={method} className="bg-gray-50 p-4 rounded-lg">
                            <h4 className="text-sm font-medium text-gray-600 capitalize">
                                {method}
                            </h4>
                            <p className="text-xl font-bold text-gray-900">
                                ${(salesByMethod[method] || 0).toFixed(2)}
                            </p>
                        </div>
                    ))}
                </div>
            </div>

            <div>
                <h3 className="text-lg font-medium mb-3">Recent Transactions</h3>
                <div className="overflow-x-auto">
                    <table className="min-w-full divide-y divide-gray-200">
                        <thead className="bg-gray-50">
                            <tr>
                                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">
                                    Time
                                </th>
                                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">
                                    Amount
                                </th>
                                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">
                                    Discount
                                </th>
                                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">
                                    Payment
                                </th>
                                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">
                                    Customer
                                </th>
                                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">
                                    Status
                                </th>
                                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">
                                    Actions
                                </th>
                            </tr>
                        </thead>
                        <tbody className="bg-white divide-y divide-gray-200">
                            {transactions.map((transaction) => (
                                <tr key={transaction.id}
                                    className={transaction.status === 'cancelled' ? 'bg-gray-50' : ''}>
                                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                                        {transaction.createdAt.toLocaleTimeString()}
                                    </td>
                                    <td className={`px-6 py-4 whitespace-nowrap text-sm font-medium ${transaction.status === 'cancelled' ? 'text-gray-400 line-through' : 'text-gray-900'
                                        }`}>
                                        ${transaction.amount.toFixed(2)}
                                    </td>
                                    <td className="px-6 py-4 whitespace-nowrap text-sm text-red-600">
                                        {transaction.discount > 0 ? `-$${transaction.discount.toFixed(2)}` : '-'}
                                    </td>
                                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500 capitalize">
                                        {transaction.type}
                                    </td>
                                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                                        {transaction.customerName || '-'}
                                    </td>
                                    <td className="px-6 py-4 whitespace-nowrap text-sm">
                                        {transaction.status === 'active' ? (
                                            <span className="text-green-600">Active</span>
                                        ) : (
                                            <span className="text-red-600">Cancelled</span>
                                        )}
                                    </td>
                                    <td className="px-6 py-4 whitespace-nowrap text-sm">
                                        {transaction.status === 'active' && currentRegister.status === 'open' && (
                                            <button
                                                onClick={() => {
                                                    if (window.confirm('Are you sure you want to cancel this transaction?')) {
                                                        onCancelTransaction(transaction.id);
                                                    }
                                                }}
                                                className="text-red-600 hover:text-red-900"
                                            >
                                                Cancel
                                            </button>
                                        )}
                                    </td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    );
};

export default SalesSummary;

# TREE_FILE_PATH: ./src\components\suppliers\SupplierForm.tsx
// src/components/suppliers/SupplierForm.tsx
import React, { useState } from 'react';

interface Supplier {
    id?: number;
    fiscalName: string;
    tradeName: string;
    contact?: string;
    phone?: string;
    email?: string;
    taxId?: string;
    address?: string;
    notes?: string;
    active: boolean;
}

interface SupplierFormProps {
    initialData?: Supplier;
    onSubmit: (data: Supplier) => Promise<void>;
    onCancel: () => void;
}

const SupplierForm: React.FC<SupplierFormProps> = ({
    initialData,
    onSubmit,
    onCancel
}) => {
    const [formData, setFormData] = useState<Supplier>({
        fiscalName: initialData?.fiscalName || '',
        tradeName: initialData?.tradeName || '',
        contact: initialData?.contact || '',
        phone: initialData?.phone || '',
        email: initialData?.email || '',
        taxId: initialData?.taxId || '',
        address: initialData?.address || '',
        notes: initialData?.notes || '',
        active: initialData?.active ?? true
    });
    const [error, setError] = useState<string | null>(null);
    const [isLoading, setIsLoading] = useState(false);

    const handleChange = (
        e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>
    ) => {
        const { name, value, type } = e.target;
        setFormData(prev => ({
            ...prev,
            [name]: type === 'checkbox'
                ? (e.target as HTMLInputElement).checked
                : value
        }));
    };

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        setError(null);
        setIsLoading(true);

        try {
            if (!formData.fiscalName.trim() || !formData.tradeName.trim()) {
                throw new Error('Fiscal name and trade name are required');
            }

            await onSubmit(formData);
        } catch (err) {
            setError(err instanceof Error ? err.message : 'Error saving supplier');
        } finally {
            setIsLoading(false);
        }
    };

    return (
        <form onSubmit={handleSubmit} className="space-y-4">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                {/* Fiscal Name */}
                <div>
                    <label className="block text-sm font-medium text-gray-700">
                        Fiscal Name *
                    </label>
                    <input
                        type="text"
                        name="fiscalName"
                        value={formData.fiscalName}
                        onChange={handleChange}
                        required
                        className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
                    />
                </div>

                {/* Trade Name */}
                <div>
                    <label className="block text-sm font-medium text-gray-700">
                        Trade Name *
                    </label>
                    <input
                        type="text"
                        name="tradeName"
                        value={formData.tradeName}
                        onChange={handleChange}
                        required
                        className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
                    />
                </div>

                {/* Contact Person */}
                <div>
                    <label className="block text-sm font-medium text-gray-700">
                        Contact Person
                    </label>
                    <input
                        type="text"
                        name="contact"
                        value={formData.contact}
                        onChange={handleChange}
                        className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
                    />
                </div>

                {/* Phone */}
                <div>
                    <label className="block text-sm font-medium text-gray-700">
                        Phone
                    </label>
                    <input
                        type="tel"
                        name="phone"
                        value={formData.phone}
                        onChange={handleChange}
                        className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
                    />
                </div>

                {/* Email */}
                <div>
                    <label className="block text-sm font-medium text-gray-700">
                        Email
                    </label>
                    <input
                        type="email"
                        name="email"
                        value={formData.email}
                        onChange={handleChange}
                        className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
                    />
                </div>

                {/* Tax ID */}
                <div>
                    <label className="block text-sm font-medium text-gray-700">
                        Tax ID (RIF/NIF)
                    </label>
                    <input
                        type="text"
                        name="taxId"
                        value={formData.taxId}
                        onChange={handleChange}
                        className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
                    />
                </div>
            </div>

            {/* Address - Full width */}
            <div>
                <label className="block text-sm font-medium text-gray-700">
                    Address
                </label>
                <input
                    type="text"
                    name="address"
                    value={formData.address}
                    onChange={handleChange}
                    className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
                />
            </div>

            {/* Notes - Full width */}
            <div>
                <label className="block text-sm font-medium text-gray-700">
                    Notes
                </label>
                <textarea
                    name="notes"
                    value={formData.notes}
                    onChange={handleChange}
                    rows={3}
                    className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
                />
            </div>

            {/* Active Status */}
            <div className="flex items-center">
                <input
                    type="checkbox"
                    name="active"
                    checked={formData.active}
                    onChange={handleChange}
                    className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
                />
                <label className="ml-2 block text-sm text-gray-700">
                    Active
                </label>
            </div>

            {error && (
                <div className="text-red-600 text-sm">{error}</div>
            )}

            <div className="flex gap-3">
                <button
                    type="submit"
                    disabled={isLoading}
                    className="flex-1 bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700 disabled:opacity-50"
                >
                    {isLoading ? 'Saving...' : initialData ? 'Update' : 'Create'}
                </button>
                <button
                    type="button"
                    onClick={onCancel}
                    className="flex-1 bg-gray-100 text-gray-700 py-2 px-4 rounded-md hover:bg-gray-200"
                >
                    Cancel
                </button>
            </div>
        </form>
    );
};

export default SupplierForm;

# TREE_FILE_PATH: ./src\components\sync\SyncStatus.tsx
import React, { useState, useEffect } from 'react';
import { Cloud, CloudOff, RefreshCw } from 'lucide-react';
import { syncQueueOperations } from '../../lib/database';
import { syncClient } from '../../lib/sync/syncClient';

const SyncStatus = () => {
    const [syncState, setSyncState] = useState({
        isOnline: navigator.onLine,
        isSyncing: false,
        pendingOps: 0
    });

    useEffect(() => {
        const updateStatus = async () => {
            const ops = await syncQueueOperations.getPendingOperations();
            setSyncState(prev => ({
                ...prev,
                pendingOps: ops.length
            }));
        };

        const onlineHandler = () => {
            setSyncState(prev => ({ ...prev, isOnline: true }));
            updateStatus();
        };

        const offlineHandler = () => {
            setSyncState(prev => ({ ...prev, isOnline: false }));
        };

        const syncStartHandler = () => {
            setSyncState(prev => ({ ...prev, isSyncing: true }));
        };

        const syncCompleteHandler = () => {
            setSyncState(prev => ({ ...prev, isSyncing: false }));
            updateStatus();
        };

        window.addEventListener('online', onlineHandler);
        window.addEventListener('offline', offlineHandler);
        syncClient.on('syncStart', syncStartHandler);
        syncClient.on('syncComplete', syncCompleteHandler);

        // Actualizar estado inicial y cada 5 segundos
        updateStatus();
        const interval = setInterval(updateStatus, 5000);

        return () => {
            window.removeEventListener('online', onlineHandler);
            window.removeEventListener('offline', offlineHandler);
            syncClient.off('syncStart', syncStartHandler);
            syncClient.off('syncComplete', syncCompleteHandler);
            clearInterval(interval);
        };
    }, []);

    const handleForceSync = () => {
        if (syncState.isOnline && !syncState.isSyncing) {
            syncClient.sync().catch(console.error);
        }
    };

    return (
        <div className="fixed bottom-4 right-4 flex items-center gap-2 bg-white p-2 rounded-lg shadow-lg">
            {/* Estado de conexi√≥n */}
            <div className="flex items-center gap-1">
                {syncState.isOnline ? (
                    <Cloud className="w-4 h-4 text-green-500" />
                ) : (
                    <CloudOff className="w-4 h-4 text-red-500" />
                )}
                <span className="text-sm">
                    {syncState.isOnline ? 'Conectado' : 'Desconectado'}
                </span>
            </div>

            {/* Operaciones pendientes */}
            {syncState.pendingOps > 0 && (
                <span className="text-sm text-orange-500">
                    {syncState.pendingOps} pendiente(s)
                </span>
            )}

            {/* Bot√≥n de sincronizaci√≥n manual */}
            <button
                onClick={handleForceSync}
                className="p-1 rounded"
                disabled={!syncState.isOnline || syncState.isSyncing}
            >
                <RefreshCw
                    className={`w-4 h-4 ${syncState.isSyncing ? 'animate-spin text-blue-500' :
                            !syncState.isOnline ? 'text-gray-400' : 'text-gray-600'
                        }`}
                />
            </button>
        </div>
    );
};

export default SyncStatus;

# TREE_FILE_PATH: ./src\context\AuthContext.tsx
// src/context/AuthContext.tsx
import React, { createContext, useContext, useState, useEffect } from 'react';
import { syncClient } from '../lib/sync/syncClient';
import { config } from '../config';

interface User {
    id: string;
    email: string;
    name: string;
    role: string;
}

interface AuthContextType {
    user: User | null;
    login: (email: string, password: string) => Promise<void>;
    logout: () => void;
    isLoading: boolean;
}

const AuthContext = createContext<AuthContextType | null>(null);

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
    const [user, setUser] = useState<User | null>(null);
    const [isLoading, setIsLoading] = useState(true);

    useEffect(() => {
        // Verificar token almacenado al cargar la aplicaci√≥n
        const token = localStorage.getItem('token');
        if (token) {
            validateToken(token);
        } else {
            setIsLoading(false);
        }
    }, []);

    const validateToken = async (token: string) => {
        try {
            const response = await fetch('`${config.apiUrl}/auth/validate', {
                headers: {
                    'Authorization': `Bearer ${token}`
                }
            });

            if (response.ok) {
                const data = await response.json();
                setUser(data.user);
            } else {
                localStorage.removeItem('token');
            }
        } catch (error) {
            localStorage.removeItem('token');
        } finally {
            setIsLoading(false);
        }
    };

    const login = async (email: string, password: string) => {
        try {
            const response = await fetch(`${config.apiUrl}/auth/login`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ email, password })
            });

            if (!response.ok) {
                throw new Error('Login failed');
            }

            const data = await response.json();
            localStorage.setItem('token', data.token);
            setUser(data.user);

            // Iniciar sincronizaci√≥n despu√©s del login exitoso
            syncClient.start();
        } catch (error) {
            throw new Error('Login failed');
        }
    };

    const logout = () => {
        localStorage.removeItem('token');
        syncClient.stop(); // Detener la sincronizaci√≥n
        setUser(null);
    };

    return (
        <AuthContext.Provider value={{ user, login, logout, isLoading }}>
            {children}
        </AuthContext.Provider>
    );
};

export const useAuth = () => {
    const context = useContext(AuthContext);
    if (!context) {
        throw new Error('useAuth must be used within an AuthProvider');
    }
    return context;
};

# TREE_FILE_PATH: ./src\context\SyncContext.tsx
import React, { createContext, useContext, useState, useEffect } from 'react';
import { syncClient } from '../lib/sync/syncClient';
import { syncQueueOperations } from '../lib/database';

interface SyncContextType {
    isSyncing: boolean;
    lastSyncTime: Date | null;
    pendingChanges: number;
    syncError: string | null;
    forceSync: () => Promise<void>;
}

const SyncContext = createContext<SyncContextType | null>(null);

export const SyncProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
    const [isSyncing, setIsSyncing] = useState(false);
    const [lastSyncTime, setLastSyncTime] = useState<Date | null>(null);
    const [pendingChanges, setPendingChanges] = useState(0);
    const [syncError, setSyncError] = useState<string | null>(null);

    // Monitorear cambios pendientes
    useEffect(() => {
        const checkPendingChanges = async () => {
            const operations = await syncQueueOperations.getPendingOperations();
            setPendingChanges(operations.length);
        };

        // Verificar inmediatamente
        checkPendingChanges();

        // Verificar peri√≥dicamente
        const interval = setInterval(checkPendingChanges, 5000);

        return () => clearInterval(interval);
    }, []);

    // Subscribirse a eventos de sincronizaci√≥n
    useEffect(() => {
        const syncStartHandler = () => {
            setIsSyncing(true);
            setSyncError(null);
        };

        const syncCompleteHandler = () => {
            setIsSyncing(false);
            setLastSyncTime(new Date());
            setSyncError(null);
        };

        const syncErrorHandler = (error: Error) => {
            setIsSyncing(false);
            setSyncError(error.message);
        };

        // Suscribirse a eventos
        syncClient.on('syncStart', syncStartHandler);
        syncClient.on('syncComplete', syncCompleteHandler);
        syncClient.on('syncError', syncErrorHandler);

        return () => {
            // Limpiar suscripciones
            syncClient.off('syncStart', syncStartHandler);
            syncClient.off('syncComplete', syncCompleteHandler);
            syncClient.off('syncError', syncErrorHandler);
        };
    }, []);

    const forceSync = async () => {
        try {
            setIsSyncing(true);
            setSyncError(null);
            await syncClient.sync();
            setLastSyncTime(new Date());
        } catch (error) {
            setSyncError(error instanceof Error ? error.message : 'Error de sincronizaci√≥n');
        } finally {
            setIsSyncing(false);
        }
    };

    return (
        <SyncContext.Provider
            value={{
                isSyncing,
                lastSyncTime,
                pendingChanges,
                syncError,
                forceSync
            }}
        >
            {children}
        </SyncContext.Provider>
    );
};

export const useSyncStatus = () => {
    const context = useContext(SyncContext);
    if (!context) {
        throw new Error('useSyncStatus must be used within a SyncProvider');
    }
    return context;
};

# TREE_FILE_PATH: ./src\lib\init.ts
import { initDatabase } from './database';
import { syncClient } from './sync/syncClient';

export const initializeApp = async () => {
    // Inicializar deviceId si no existe
    if (!localStorage.getItem('deviceId')) {
        localStorage.setItem('deviceId', crypto.randomUUID());
    }

    // Inicializar la base de datos
    await initDatabase();

    // Iniciar sincronizaci√≥n
    syncClient.start();
};

// Funci√≥n para limpiar recursos cuando la app se cierra
export const cleanupApp = () => {
    syncClient.stop();
};

# TREE_FILE_PATH: ./src\lib\database\index.ts
import { openDB, IDBPDatabase } from 'idb';
import { config } from '../../config';
import { Product, Transaction } from '../../types';

type CreateProductData = Omit<Product, 'id' | 'createdAt' | 'updatedAt'>;
type UpdateProductData = Partial<CreateProductData>;

// Interfaces
interface CashRegister {
    id: number;
    status: 'open' | 'closed';
    initialAmount: number;
    finalAmount?: number;
    openedAt: Date;
    closedAt?: Date;
}

interface SyncQueueItem {
    id: string;
    timestamp: number;
    type: 'create' | 'update' | 'delete';
    entity: 'product' | 'transaction' | 'cashRegister';
    data: string;
    deviceId: string;
    status: 'pending' | 'completed' | 'failed';
}

interface DBSchema {
    products: {
        key: number;
        value: Product;
        indexes: { 'by-category': string };
    };
    transactions: {
        key: number;
        value: Transaction;
    };
    cashRegister: {
        key: number;
        value: CashRegister;
    };
    syncQueue: {
        key: string;
        value: SyncQueueItem;
        indexes: { 'by-status': string };
    };
}

let db: IDBPDatabase<DBSchema>;

export const initDatabase = async () => {
    if (db) return db;

    db = await openDB<DBSchema>('pos-db', 2, {  // Incrementar versi√≥n a 2
        upgrade(db, oldVersion, newVersion) {
            // Stores existentes
            if (!db.objectStoreNames.contains('products')) {
                const productStore = db.createObjectStore('products', { keyPath: 'id', autoIncrement: true });
                productStore.createIndex('by-category', 'category');
            }

            if (!db.objectStoreNames.contains('transactions')) {
                // Si existe la store antigua, la eliminamos
                if (oldVersion < 2 && db.objectStoreNames.contains('transactions')) {
                    db.deleteObjectStore('transactions');
                }
                // Crear nueva store con la estructura actualizada
                db.createObjectStore('transactions', { keyPath: 'id', autoIncrement: true });
            }

            if (!db.objectStoreNames.contains('cashRegister')) {
                db.createObjectStore('cashRegister', { keyPath: 'id', autoIncrement: true });
            }

            if (!db.objectStoreNames.contains('syncQueue')) {
                const syncStore = db.createObjectStore('syncQueue', { keyPath: 'id' });
                syncStore.createIndex('by-status', 'status');
            }
        },
    });

    return db;
};

// Funci√≥n auxiliar para encolar operaciones de sincronizaci√≥n
const enqueueSyncOperation = async (operation: Omit<SyncQueueItem, 'id' | 'timestamp'>) => {
    const db = await initDatabase();
    const syncOp: SyncQueueItem = {
        ...operation,
        id: crypto.randomUUID(),
        timestamp: Date.now(),
    };

    await db.add('syncQueue', syncOp);
    return syncOp;
};

// Operaciones de productos
export const productOperations = {
    async create(product: CreateProductData) {
        console.log('Starting product creation with data:', {
            ...product,
            imageUrl: product.imageUrl ? 'Base64 image exists' : 'No image'
        });

        try {
            const response = await fetch(`${config.apiUrl}/products`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${localStorage.getItem('token')}`
                },
                body: JSON.stringify(product)
            });

            console.log('Server response status:', response.status);
            if (!response.ok) {
                const error = await response.json();
                console.error('Server error:', error);
                throw new Error(error.error || 'Error creating product');
            }

            const serverProduct = await response.json();

            // Si el backend acepta, entonces guardar en IndexedDB
            const db = await initDatabase();
            const productToStore = {
                ...serverProduct,
                createdAt: new Date(serverProduct.createdAt),
                updatedAt: new Date(serverProduct.updatedAt)
            };

            await db.put('products', productToStore);
            console.log('Product created successfully:', JSON.stringify(productToStore, null, 2));

            return serverProduct.id;
        } catch (error) {
            console.error('Error creating product:', error);
            throw error;
        }
    },

    async update(id: number, productData: UpdateProductData) {
        console.log('Starting product update:', { id, updates: productData });

        try {
            // Primero actualizar en el backend
            const response = await fetch(`${config.apiUrl}/products/${id}`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${localStorage.getItem('token')}`
                },
                body: JSON.stringify(productData)
            });

            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error || 'Error updating product');
            }

            const serverProduct = await response.json();

            // Si el backend acepta, actualizar en IndexedDB
            const db = await initDatabase();
            const productToStore = {
                ...serverProduct,
                createdAt: new Date(serverProduct.createdAt),
                updatedAt: new Date(serverProduct.updatedAt)
            };

            await db.put('products', productToStore);
            console.log('Product updated successfully:', productToStore);

            return productToStore;
        } catch (error) {
            console.error('Error updating product:', error);
            throw error;
        }
    },

    async delete(id: number) {
        console.log('Starting product deletion:', id);

        try {
            // Primero eliminar en el backend
            const response = await fetch(`${config.apiUrl}/products/${id}`, {
                method: 'DELETE',
                headers: {
                    'Authorization': `Bearer ${localStorage.getItem('token')}`
                }
            });

            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error || 'Error deleting product');
            }

            // Si el backend acepta, eliminar de IndexedDB
            const db = await initDatabase();
            await db.delete('products', id);
            console.log('Product deleted successfully');

        } catch (error) {
            console.error('Error deleting product:', error);
            throw error;
        }
    },

    async getAll() {
        const db = await initDatabase();
        return db.getAll('products');
    },

    async getById(id: number) {
        const db = await initDatabase();
        return db.get('products', id);
    }
};

export const transactionOperations = {
    async create(transaction: Omit<Transaction, 'id'>) {
        const db = await initDatabase();
        const id = await db.add('transactions', transaction);

        // Encolar para sincronizaci√≥n
        await enqueueSyncOperation({
            type: 'create',
            entity: 'transaction',
            data: JSON.stringify({ ...transaction, id }),
            deviceId: localStorage.getItem('deviceId') || 'unknown',
            status: 'pending'
        });

        return id;
    },

    async cancelTransaction(id: number) {
        try {
            // Primero intentar en el backend
            const response = await fetch(`${config.apiUrl}/transactions/${id}/cancel`, {
                method: 'PUT',
                headers: {
                    'Authorization': `Bearer ${localStorage.getItem('token')}`
                }
            });

            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error || 'Error cancelling transaction');
            }

            const updatedTransaction = await response.json();

            // Si el backend acepta, actualizar en IndexedDB
            const db = await initDatabase();
            await db.put('transactions', {
                ...updatedTransaction,
                createdAt: new Date(updatedTransaction.createdAt)
            });

            return updatedTransaction;
        } catch (error) {
            console.error('Error cancelling transaction:', error);
            throw error;
        }
    },

    async getAll() {
        const db = await initDatabase();
        return await db.getAll('transactions');
    },

    async getById(id: number) {
        const db = await initDatabase();
        return await db.get('transactions', id);
    }
};

// Operaciones de caja registradora
export const cashRegisterOperations = {
    async create(register: Omit<CashRegister, 'id'>) {
        const db = await initDatabase();
        const data = {
            ...register,
            deviceId: localStorage.getItem('deviceId') || 'unknown'
        };
        const id = await db.add('cashRegister', data);

        await enqueueSyncOperation({
            type: 'create',
            entity: 'cashRegister',
            data: JSON.stringify({ ...data, id }),
            deviceId: data.deviceId,
            status: 'pending'
        });

        return id;
    },

    async update(id: number, data: Partial<CashRegister>) {
        const db = await initDatabase();
        console.log('Updating register:', id, 'with data:', data);
        const existing = await db.get('cashRegister', id);
        console.log('Existing register:', existing);
        if (!existing) throw new Error('Register not found');

        const updated = { ...existing, ...data };
        console.log('Updated register data:', updated);

        try {
            await db.put('cashRegister', updated);
            console.log('Register updated in IndexedDB');

            // Resto del c√≥digo...
        } catch (error) {
            console.error('Error updating register:', error);
            throw error;
        }

        return updated;
    },

    async getById(id: number) {
        const db = await initDatabase();
        return await db.get('cashRegister', id);
    },

    async getCurrent(userId?: string) {
        const db = await initDatabase();
        console.log('Checking registers for user:', userId);
        const registers = await db.getAll('cashRegister');
        console.log('All registers:', registers);

        if (!userId) return registers[registers.length - 1];

        const filtered = registers.filter(reg => reg.userId === userId && reg.status === 'open');
        console.log('Filtered registers:', filtered);
        return filtered.pop();
    }
};

// Operaciones de la cola de sincronizaci√≥n
export const syncQueueOperations = {
    async getPendingOperations() {
        const db = await initDatabase();
        return db.getAllFromIndex('syncQueue', 'by-status', 'pending');
    },

    async markAsCompleted(id: string) {
        const db = await initDatabase();
        const operation = await db.get('syncQueue', id);
        if (operation) {
            operation.status = 'completed';
            await db.put('syncQueue', operation);
        }
    },

    async markAsFailed(id: string) {
        const db = await initDatabase();
        const operation = await db.get('syncQueue', id);
        if (operation) {
            operation.status = 'failed';
            await db.put('syncQueue', operation);
        }
    },

    async clearCompleted() {
        const db = await initDatabase();
        const tx = db.transaction('syncQueue', 'readwrite');
        const completed = await tx.store.index('by-status').getAllKeys('completed');
        await Promise.all(completed.map(key => tx.store.delete(key)));
        await tx.done;
    },

    async clearAll() {
        const db = await initDatabase();
        const tx = db.transaction('syncQueue', 'readwrite');
        await tx.store.clear();
        await tx.done;
    }
};

export const clearDatabase = async () => {
    const db = await initDatabase();
    await db.clear('products');
    await db.clear('transactions');
    await db.clear('cashRegister');
    await db.clear('syncQueue');
    console.log('Local database cleared');
};

# TREE_FILE_PATH: ./src\lib\sync\syncClient.ts
import { syncQueueOperations, initDatabase, clearDatabase } from '../database';
import { SyncOperation, SyncRequest, SyncResponse } from '../../types/sync';
import { EventEmitter } from '../utils/EventEmitter';
import { config } from '../../config';

// Definir los tipos de eventos que emitir√° el cliente
interface SyncEvents {
    syncStart: () => void;
    syncComplete: () => void;
    syncError: (error: Error) => void;
}

declare interface SyncClient {
    on<E extends keyof SyncEvents>(event: E, listener: SyncEvents[E]): this;
    off<E extends keyof SyncEvents>(event: E, listener: SyncEvents[E]): this;
    emit<E extends keyof SyncEvents>(event: E, ...args: Parameters<SyncEvents[E]>): boolean;
}

class SyncClient extends EventEmitter {
    private isRunning = false;
    private syncInterval: number = 30000;
    private lastSyncTimestamp: number = 0;
    private intervalId?: number;
    private isOnline: boolean = true;

    constructor(private apiUrl: string = config.apiUrl.replace('/api', '')) {
        super();
        console.log('SyncClient initialized with URL:', this.apiUrl);
        this.isOnline = navigator.onLine;

        window.addEventListener('online', () => {
            console.log('Connection restored');
            this.isOnline = true;
            this.sync().catch(console.error);
        });

        window.addEventListener('offline', () => {
            console.log('Connection lost');
            this.isOnline = false;
        });
    }

    private getAuthToken(): string | null {
        return localStorage.getItem('token');
    }

    async start() {
        if (this.isRunning) return;

        const token = this.getAuthToken();
        if (!token) {
            console.log('No auth token, skipping sync');
            return;
        }

        this.isRunning = true;
        await this.initialSync();
        this.scheduleSync();
    }

    private async initialSync() {
        try {
            const token = this.getAuthToken();
            if (!token || !this.isOnline) {
                return;
            }

            console.log('Performing initial sync...');

            // Solo limpiar si no hay operaciones pendientes
            const pendingOps = await syncQueueOperations.getPendingOperations();
            if (pendingOps.length === 0) {
                // Solo limpiar si la base de datos est√° vac√≠a
                const db = await initDatabase();
                const products = await db.getAll('products');
                if (products.length === 0) {
                    await clearDatabase();
                }
            }

            const response = await fetch(`${this.apiUrl}/sync`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${token}`
                },
                body: JSON.stringify({
                    operations: [],
                    lastSyncTimestamp: 0,
                    deviceId: localStorage.getItem('deviceId') || 'unknown'
                })
            });

            if (!response.ok) {
                throw new Error(`Initial sync failed: ${response.statusText}`);
            }

            const syncResponse: SyncResponse = await response.json();
            if (syncResponse.success) {
                await syncQueueOperations.clearAll();
                await this.applyRemoteOperations(syncResponse.operations);
                this.lastSyncTimestamp = syncResponse.lastSyncTimestamp;
            }
        } catch (error) {
            console.error('Initial sync error:', error);
        }
    }

    stop() {
        this.isRunning = false;
        if (this.intervalId) {
            window.clearInterval(this.intervalId);
        }
    }

    async sync(): Promise<void> {
        const token = this.getAuthToken();
        if (!token || !this.isOnline) {
            console.log('Skipping sync - no token or offline');
            return;
        }

        this.emit('syncStart');
        try {
            const pendingOperations = await syncQueueOperations.getPendingOperations();

            const syncRequest: SyncRequest = {
                operations: pendingOperations,
                lastSyncTimestamp: this.lastSyncTimestamp,
                deviceId: localStorage.getItem('deviceId') || 'unknown'
            };

            const response = await fetch(`${this.apiUrl}/sync`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${token}`
                },
                body: JSON.stringify(syncRequest)
            });

            if (!response.ok) {
                throw new Error(`Sync failed: ${response.statusText}`);
            }

            const syncResponse: SyncResponse = await response.json();
            if (syncResponse.success) {
                await Promise.all(
                    pendingOperations.map(op =>
                        syncQueueOperations.markAsCompleted(op.id)
                    )
                );

                await this.applyRemoteOperations(syncResponse.operations);
                this.lastSyncTimestamp = syncResponse.lastSyncTimestamp;
                await syncQueueOperations.clearCompleted();
                this.emit('syncComplete');
            } else {
                throw new Error(syncResponse.error || 'Sync failed');
            }
        } catch (error) {
            // Convertir el error a una instancia de Error si no lo es
            const errorToEmit = error instanceof Error ? error : new Error(String(error));
            this.emit('syncError', errorToEmit);
            console.error('Sync error:', error);
            throw error;
        }
    }

    private scheduleSync() {
        this.intervalId = window.setInterval(() => {
            if (navigator.onLine) {
                this.sync().catch(console.error);
            }
        }, this.syncInterval);
    }

    private async applyRemoteOperations(operations: SyncOperation[]): Promise<void> {
        const {
            productOperations,
            transactionOperations,
            cashRegisterOperations
        } = await import('../database');

        for (const operation of operations) {
            try {
                const data = JSON.parse(operation.data);

                switch (operation.entity) {
                    case 'product':
                        // Verificar si el producto existe antes de intentar crearlo
                        const existingProduct = await productOperations.getById(data.id);

                        switch (operation.type) {
                            case 'create':
                                if (!existingProduct) {
                                    await productOperations.create(data);
                                }
                                break;
                            case 'update':
                                if (existingProduct) {
                                    await productOperations.update(data.id, data);
                                }
                                break;
                            case 'delete':
                                if (existingProduct) {
                                    await productOperations.delete(data.id);
                                }
                                break;
                        }
                        break;

                    case 'transaction':
                        const existingTransaction = await transactionOperations.getById?.(data.id);

                        switch (operation.type) {
                            case 'create':
                                if (!existingTransaction) {
                                    await transactionOperations.create(data);
                                }
                                break;
                            // Normalmente no permitimos actualizar o eliminar transacciones
                        }
                        break;

                    case 'cashRegister':
                        const existingRegister = await cashRegisterOperations.getById?.(data.id);

                        switch (operation.type) {
                            case 'create':
                                if (!existingRegister) {
                                    await cashRegisterOperations.create(data);
                                }
                                break;
                            case 'update':
                                if (existingRegister) {
                                    await cashRegisterOperations.update(data.id, data);
                                }
                                break;
                        }
                        break;
                }
            } catch (error) {
                if (error instanceof Error && error.name !== 'ConstraintError') {
                    console.error(`Failed to apply remote operation:`, operation, error);
                }
            }
        }
    }

    async forceFullSync() {
        try {
            console.log('Forcing full sync...');

            // Limpiar la base de datos local
            const db = await initDatabase();
            await db.clear('products');
            await syncQueueOperations.clearAll();

            // Resetear el timestamp para forzar una sincronizaci√≥n inicial
            this.lastSyncTimestamp = 0;
            console.log('Reset lastSyncTimestamp to 0');

            // Realizar sincronizaci√≥n inicial
            await this.initialSync();

            console.log('Full sync completed');
        } catch (error) {
            console.error('Full sync failed:', error);
            throw error;
        }
    }
}

export const syncClient = new SyncClient(config.apiUrl);

# TREE_FILE_PATH: ./src\lib\utils\EventEmitter.ts
type EventCallback = (...args: any[]) => void;

export class EventEmitter {
    private events: { [key: string]: EventCallback[] } = {};

    on(event: string, callback: EventCallback) {
        if (!this.events[event]) {
            this.events[event] = [];
        }
        this.events[event].push(callback);
        return this;
    }

    off(event: string, callback: EventCallback) {
        if (!this.events[event]) return this;
        this.events[event] = this.events[event].filter(cb => cb !== callback);
        return this;
    }

    emit(event: string, ...args: any[]) {
        if (!this.events[event]) return false;
        this.events[event].forEach(callback => callback(...args));
        return true;
    }
}

# TREE_FILE_PATH: ./src\pages\Login.tsx
// src/pages/Login.tsx
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';

const Login = () => {
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');
    const [error, setError] = useState('');
    const { login } = useAuth();
    const navigate = useNavigate();

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        setError('');

        try {
            await login(email, password);
            navigate('/inventory'); // Redirigir al inventario despu√©s del login
        } catch (err) {
            setError('Invalid credentials');
        }
    };

    return (
        <div className="min-h-screen flex items-center justify-center bg-gray-50">
            <div className="max-w-md w-full space-y-8 p-8 bg-white rounded-lg shadow">
                <div>
                    <h2 className="text-center text-3xl font-bold">Mini POS</h2>
                    <p className="mt-2 text-center text-gray-600">Sign in to your account</p>
                </div>

                {error && (
                    <div className="bg-red-50 text-red-500 p-3 rounded">
                        {error}
                    </div>
                )}

                <form className="mt-8 space-y-6" onSubmit={handleSubmit}>
                    <div className="space-y-4">
                        <div>
                            <label htmlFor="email" className="block text-sm font-medium text-gray-700">
                                Email
                            </label>
                            <input
                                id="email"
                                type="email"
                                required
                                value={email}
                                onChange={(e) => setEmail(e.target.value)}
                                className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
                            />
                        </div>
                        <div>
                            <label htmlFor="password" className="block text-sm font-medium text-gray-700">
                                Password
                            </label>
                            <input
                                id="password"
                                type="password"
                                required
                                value={password}
                                onChange={(e) => setPassword(e.target.value)}
                                className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
                            />
                        </div>
                    </div>

                    <button
                        type="submit"
                        className="w-full py-2 px-4 border border-transparent rounded-md shadow-sm text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
                    >
                        Sign in
                    </button>
                </form>
            </div>
        </div>
    );
};

export default Login;

# TREE_FILE_PATH: ./src\pages\admin\SuppliersPage.tsx
// src/pages/admin/SuppliersPage.tsx
import React, { useState, useEffect } from 'react';
import SupplierForm from '../../components/suppliers/SupplierForm';
import { config } from '../../config';

interface Supplier {
    id: number;
    fiscalName: string;
    tradeName: string;
    contact?: string;
    phone?: string;
    email?: string;
    taxId?: string;
    address?: string;
    notes?: string;
    active: boolean;
}

const SuppliersPage = () => {
    const [suppliers, setSuppliers] = useState<Supplier[]>([]);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);
    const [showForm, setShowForm] = useState(false);
    const [editingSupplier, setEditingSupplier] = useState<Supplier | null>(null);

    useEffect(() => {
        loadSuppliers();
    }, []);

    const loadSuppliers = async () => {
        try {
            setIsLoading(true);
            const response = await fetch(`${config.apiUrl}/suppliers`, {
                headers: {
                    'Authorization': `Bearer ${localStorage.getItem('token')}`
                }
            });

            if (!response.ok) {
                throw new Error('Failed to load suppliers');
            }

            const data = await response.json();
            setSuppliers(data);
        } catch (err) {
            setError('Error loading suppliers');
        } finally {
            setIsLoading(false);
        }
    };

    const handleSave = async (supplierData: Omit<Supplier, 'id'>) => {
        try {
            const url = editingSupplier
                ? `${config.apiUrl}/suppliers/${editingSupplier.id}`
                : `${config.apiUrl}/suppliers`;

            const response = await fetch(url, {
                method: editingSupplier ? 'PUT' : 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${localStorage.getItem('token')}`
                },
                body: JSON.stringify(supplierData)
            });

            if (!response.ok) {
                const data = await response.json();
                throw new Error(data.error || 'Error saving supplier');
            }

            await loadSuppliers();
            setShowForm(false);
            setEditingSupplier(null);
        } catch (error) {
            throw error;
        }
    };

    const handleEdit = (supplier: Supplier) => {
        setEditingSupplier(supplier);
        setShowForm(true);
    };

    const handleDelete = async (supplierId: number) => {
        if (!confirm('Are you sure you want to delete this supplier?')) return;

        try {
            const response = await fetch(`${config.apiUrl}/suppliers/${supplierId}`, {
                method: 'DELETE',
                headers: {
                    'Authorization': `Bearer ${localStorage.getItem('token')}`
                }
            });

            if (!response.ok) {
                throw new Error('Failed to delete supplier');
            }

            await loadSuppliers();
        } catch (err) {
            setError('Error deleting supplier');
        }
    };

    if (isLoading) return <div>Loading...</div>;

    return (
        <div className="p-6">
            <div className="flex justify-between items-center mb-6">
                <h1 className="text-2xl font-bold">Suppliers</h1>
                <button
                    onClick={() => setShowForm(true)}
                    className="bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700"
                >
                    Add Supplier
                </button>
            </div>

            {error && (
                <div className="bg-red-50 text-red-600 p-4 rounded-md mb-4">
                    {error}
                </div>
            )}

            <div className="bg-white rounded-lg shadow overflow-hidden">
                <div className="overflow-x-auto">
                    <table className="min-w-full divide-y divide-gray-200">
                        <thead className="bg-gray-50">
                            <tr>
                                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                    ID
                                </th>
                                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                    Fiscal Name
                                </th>
                                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                    Trade Name
                                </th>
                                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                    Contact
                                </th>
                                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                    Phone/Email
                                </th>
                                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                    Tax ID
                                </th>
                                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                    Status
                                </th>
                                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                    Actions
                                </th>
                            </tr>
                        </thead>
                        <tbody className="bg-white divide-y divide-gray-200">
                            {suppliers.map((supplier) => (
                                <tr key={supplier.id}>
                                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                                        {supplier.id}
                                    </td>
                                    <td className="px-6 py-4 whitespace-nowrap">
                                        <div className="text-sm font-medium text-gray-900">
                                            {supplier.fiscalName}
                                        </div>
                                    </td>
                                    <td className="px-6 py-4 whitespace-nowrap">
                                        <div className="text-sm text-gray-900">
                                            {supplier.tradeName}
                                        </div>
                                    </td>
                                    <td className="px-6 py-4 whitespace-nowrap">
                                        <div className="text-sm text-gray-900">
                                            {supplier.contact || '-'}
                                        </div>
                                    </td>
                                    <td className="px-6 py-4 whitespace-nowrap">
                                        <div className="text-sm text-gray-900">
                                            {supplier.phone && (
                                                <div>{supplier.phone}</div>
                                            )}
                                            {supplier.email && (
                                                <div className="text-gray-500">{supplier.email}</div>
                                            )}
                                        </div>
                                    </td>
                                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                                        {supplier.taxId || '-'}
                                    </td>
                                    <td className="px-6 py-4 whitespace-nowrap">
                                        <span className={`px - 2 inline - flex text - xs leading - 5 font - semibold rounded - full ${supplier.active
                                            ? 'bg-green-100 text-green-800'
                                            : 'bg-red-100 text-red-800'
                                            }`}>
                                            {supplier.active ? 'Active' : 'Inactive'}
                                        </span>
                                    </td>
                                    <td className="px-6 py-4 whitespace-nowrap text-sm font-medium">
                                        <button
                                            onClick={() => handleEdit(supplier)}
                                            className="text-blue-600 hover:text-blue-900 mr-4"
                                        >
                                            Edit
                                        </button>
                                        <button
                                            onClick={() => handleDelete(supplier.id)}
                                            className="text-red-600 hover:text-red-900"
                                        >
                                            Delete
                                        </button>
                                    </td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                </div>
            </div>

            {/* Modal para el formulario */}
            {showForm && (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4">
                    <div className="bg-white rounded-lg p-6 max-w-2xl w-full">
                        <h2 className="text-xl font-bold mb-4">
                            {editingSupplier ? 'Edit Supplier' : 'Add New Supplier'}
                        </h2>
                        <SupplierForm
                            initialData={editingSupplier || undefined}
                            onSubmit={handleSave}
                            onCancel={() => {
                                setShowForm(false);
                                setEditingSupplier(null);
                            }}
                        />
                    </div>
                </div>
            )}
        </div>
    );
};

export default SuppliersPage;

# TREE_FILE_PATH: ./src\pages\admin\UsersPage.tsx
// src/pages/admin/UsersPage.tsx
import React, { useState, useEffect } from 'react';
import { useAuth } from '../../context/AuthContext';
import UserForm from '../../components/admin/UserForm';
import { config } from '../../config';

interface User {
    id: string;
    name: string;
    email: string;
    role: string;
    active: boolean;
}

const UsersPage = () => {
    const [users, setUsers] = useState<User[]>([]);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);
    const [showForm, setShowForm] = useState(false);
    const { user: currentUser } = useAuth();

    useEffect(() => {
        loadUsers();
    }, []);

    const loadUsers = async () => {
        try {
            const response = await fetch(`${config.apiUrl}/admin/users`, {
                headers: {
                    'Authorization': `Bearer ${localStorage.getItem('token')}`
                }
            });

            if (!response.ok) throw new Error('Failed to load users');

            const data = await response.json();
            setUsers(data);
        } catch (err) {
            setError('Error loading users');
        } finally {
            setIsLoading(false);
        }
    };

    const handleCreateUser = async (userData: any) => {
        try {
            const response = await fetch(`${config.apiUrl}/admin/users`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${localStorage.getItem('token')}`
                },
                body: JSON.stringify(userData)
            });

            if (!response.ok) {
                const data = await response.json();
                throw new Error(data.error || 'Error creating user');
            }

            await loadUsers();
            setShowForm(false);
        } catch (error) {
            throw error;
        }
    };

    const handleToggleStatus = async (userId: string) => {
        try {
            const response = await fetch(`${config.apiUrl}/admin/users/${userId}/toggle-status`, {
                method: 'PATCH',
                headers: {
                    'Authorization': `Bearer ${localStorage.getItem('token')}`
                }
            });

            if (!response.ok) {
                throw new Error('Failed to update user status');
            }

            await loadUsers();
        } catch (err) {
            setError('Error updating user status');
        }
    };

    if (isLoading) return <div>Loading...</div>;
    if (error) return <div className="text-red-600">{error}</div>;

    return (
        <div className="p-6">
            <div className="flex justify-between items-center mb-6">
                <h1 className="text-2xl font-bold">User Management</h1>
                <button
                    onClick={() => setShowForm(true)}
                    className="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600"
                >
                    Add User
                </button>
            </div>

            <div className="bg-white rounded-lg shadow overflow-hidden">
                <table className="min-w-full divide-y divide-gray-200">
                    <thead className="bg-gray-50">
                        <tr>
                            <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">
                                Name
                            </th>
                            <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">
                                Email
                            </th>
                            <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">
                                Role
                            </th>
                            <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">
                                Status
                            </th>
                            <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">
                                Actions
                            </th>
                        </tr>
                    </thead>
                    <tbody className="bg-white divide-y divide-gray-200">
                        {users.map((user) => (
                            <tr key={user.id}>
                                <td className="px-6 py-4 whitespace-nowrap">{user.name}</td>
                                <td className="px-6 py-4 whitespace-nowrap">{user.email}</td>
                                <td className="px-6 py-4 whitespace-nowrap">{user.role}</td>
                                <td className="px-6 py-4 whitespace-nowrap">
                                    <span className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${user.active
                                        ? 'bg-green-100 text-green-800'
                                        : 'bg-red-100 text-red-800'
                                        }`}>
                                        {user.active ? 'Active' : 'Inactive'}
                                    </span>
                                </td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm font-medium">
                                    <button
                                        onClick={() => handleToggleStatus(user.id)}
                                        disabled={user.email === 'admin@example.com'}
                                        className={`text-${user.active ? 'red' : 'green'}-600 hover:text-${user.active ? 'red' : 'green'}-900 disabled:opacity-50`}
                                    >
                                        {user.active ? 'Deactivate' : 'Activate'}
                                    </button>
                                </td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>

            {showForm && (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4">
                    <div className="bg-white rounded-lg p-6 max-w-md w-full">
                        <h2 className="text-xl font-bold mb-4">Create New User</h2>
                        <UserForm
                            onSubmit={handleCreateUser}
                            onCancel={() => setShowForm(false)}
                        />
                    </div>
                </div>
            )}
        </div>
    );
};

export default UsersPage;

# TREE_FILE_PATH: ./src\pages\inventory\InventoryPage.tsx
// src/pages/inventory/InventoryPage.tsx
import React, { useState, useEffect } from 'react';
import { Product } from '../../types';
import { productOperations } from '../../lib/database';
import ProductForm from '../../components/inventory/ProductForm';
import SearchBar from '../../components/common/SearchBar';
import { config } from '../../config';
import { syncClient } from '../../lib/sync/syncClient';


const InventoryPage = () => {
    const [products, setProducts] = useState<Product[]>([]);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);
    const [showAddForm, setShowAddForm] = useState(false);
    const [editingProduct, setEditingProduct] = useState<Product | null>(null);
    const [selectedCategory, setSelectedCategory] = useState<string | null>(null);
    const [searchTerm, setSearchTerm] = useState('');

    useEffect(() => {
        loadProducts();
    }, []);

    const loadProducts = async () => {
        try {
            setIsLoading(true);
            const allProducts = await productOperations.getAll();
            setProducts(allProducts);
            checkLowStock(allProducts);
        } catch (err) {
            setError('Error loading products');
        } finally {
            setIsLoading(false);
        }
    };

    const checkLowStock = (products: Product[]) => {
        const lowStockProducts = products.filter(p =>
            p.stock <= (p.minStock ?? 5)
        );

        if (lowStockProducts.length > 0) {
            const message = lowStockProducts
                .map(p => `${p.name}: ${p.stock} left`)
                .join('\n');
            alert(`Low stock alert!\n${message}`);
        }
    };

    const handleDelete = async (productId: number) => {
        if (!confirm('Are you sure you want to delete this product?')) return;

        try {
            await productOperations.delete(productId);
            loadProducts();
        } catch (err) {
            setError('Error deleting product');
        }
    };

    const handleToggleStatus = async (productId: number) => {
        try {
            console.log('Frontend: Toggling status for product:', productId);
            const response = await fetch(`${config.apiUrl}/products/${productId}/toggle-status`, {
                method: 'PATCH',
                headers: {
                    'Authorization': `Bearer ${localStorage.getItem('token')}`
                }
            });

            if (!response.ok) throw new Error('Failed to toggle status');

            const updatedProduct = await response.json();
            console.log('Frontend: Updated product data:', updatedProduct);

            // Actualizar el estado local inmediatamente
            setProducts(prevProducts =>
                prevProducts.map(product =>
                    product.id === productId
                        ? { ...product, isActive: updatedProduct.isActive }
                        : product
                )
            );

            // Forzar sincronizaci√≥n
            await syncClient.sync();
        } catch (err) {
            console.error('Frontend: Error in handleToggleStatus:', err);
            setError('Error toggling product status');
        }
    };

    const filteredProducts = selectedCategory
        ? products.filter(p => p.category === selectedCategory)
        : products;

    const searchFilteredProducts = filteredProducts.filter(product => {
        const searchLower = searchTerm.toLowerCase();
        return product.name.toLowerCase().includes(searchLower) ||
            (product.barcode && product.barcode.toLowerCase().includes(searchLower));
    });

    return (
        <div className="p-6">
            <div className="flex justify-between items-center mb-6">
                <h1 className="text-2xl font-bold">Inventory Management</h1>
                <button
                    onClick={() => setShowAddForm(true)}
                    className="bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700"
                >
                    Add Product
                </button>
            </div>

            {error && (
                <div className="bg-red-50 text-red-600 p-4 rounded-md mb-4">
                    {error}
                </div>
            )}

            <div className="mb-4 flex gap-4">
                <div className="flex-1">
                    <SearchBar
                        value={searchTerm}
                        onChange={setSearchTerm}
                        placeholder="Search by name or barcode..."
                    />
                </div>
                <div className="flex gap-2">
                    <button
                        onClick={() => setSelectedCategory(null)}
                        className={`px-4 py-2 rounded-lg ${selectedCategory === null
                            ? 'bg-blue-600 text-white'
                            : 'bg-gray-100 text-gray-800'
                            }`}
                    >
                        All
                    </button>
                    {['Wines', 'Beers', 'Spirits', 'Food', 'Others'].map(category => (
                        <button
                            key={category}
                            onClick={() => setSelectedCategory(category)}
                            className={`px-4 py-2 rounded-lg ${selectedCategory === category
                                ? 'bg-blue-600 text-white'
                                : 'bg-gray-100 text-gray-800'
                                }`}
                        >
                            {category}
                        </button>
                    ))}
                </div>
            </div>

            {isLoading ? (
                <div>Loading...</div>
            ) : (
                <div className="bg-white rounded-lg shadow overflow-hidden">
                    <table className="min-w-full divide-y divide-gray-200">
                        <thead className="bg-gray-50">
                            <tr>
                                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">
                                    Image
                                </th>
                                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">
                                    Name
                                </th>
                                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">
                                    Category
                                </th>
                                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">
                                    Price
                                </th>
                                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">
                                    Stock
                                </th>
                                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">
                                    Status
                                </th>
                                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">
                                    Actions
                                </th>
                            </tr>
                        </thead>
                        <tbody className="bg-white divide-y divide-gray-200">
                            {searchFilteredProducts.map((product) => (
                                <tr key={product.id}>
                                    <td className="px-6 py-4 whitespace-nowrap">
                                        {product.imageUrl ? (
                                            <img
                                                src={product.imageUrl}
                                                alt={product.name}
                                                className="h-12 w-12 object-cover rounded-md"
                                            />
                                        ) : (
                                            <div className="h-12 w-12 bg-gray-100 rounded-md flex items-center justify-center text-gray-400">
                                                No image
                                            </div>
                                        )}
                                    </td>
                                    <td className="px-6 py-4 whitespace-nowrap">
                                        <div className="text-sm font-medium text-gray-900">
                                            {product.name}
                                        </div>
                                        {product.barcode && (
                                            <div className="text-sm text-gray-500">
                                                {product.barcode}
                                            </div>
                                        )}
                                    </td>
                                    <td className="px-6 py-4 whitespace-nowrap">
                                        {product.category}
                                    </td>
                                    <td className="px-6 py-4 whitespace-nowrap">
                                        ${product.price.toFixed(2)}
                                    </td>
                                    <td className="px-6 py-4 whitespace-nowrap">
                                        <span className={`inline-flex rounded-full px-2 text-xs font-semibold ${product.stock <= (product.minStock ?? 5)
                                            ? 'bg-red-100 text-red-800'
                                            : 'bg-green-100 text-green-800'
                                            }`}>
                                            {product.stock}
                                        </span>
                                    </td>

                                    <td className="px-6 py-4 whitespace-nowrap">
                                        {product.isActive ? 'Active' : 'Inactive'}
                                    </td>

                                    <td className="px-6 py-4 whitespace-nowrap text-sm font-medium">
                                        <button
                                            onClick={() => setEditingProduct(product)}
                                            className="text-blue-600 hover:text-blue-900 mr-4"
                                        >
                                            Edit
                                        </button>

                                        <button
                                            onClick={() => handleDelete(product.id)}
                                            className="text-red-600 hover:text-red-900"
                                        >
                                            Delete
                                        </button>

                                        {/*<button
                                            onClick={() => {
                                                console.log('Toggle button clicked for product:', product.id);
                                                handleToggleStatus(product.id);
                                            }}
                                            className={`${product.isActive ? 'text-red-600 hover:text-red-900' : 'text-green-600 hover:text-green-900'
                                                }`}
                                        >
                                            {product.isActive ? 'Deactivate' : 'Activate'}
                                        </button>*/}
                                    </td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                </div>
            )}

            {(showAddForm || editingProduct) && (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4">
                    <div className="bg-white rounded-lg p-6 max-w-md w-full">
                        <h2 className="text-xl font-bold mb-4">
                            {editingProduct ? 'Edit Product' : 'Add New Product'}
                        </h2>
                        <ProductForm
                            initialProduct={editingProduct ?? undefined}
                            onSubmit={() => {
                                setShowAddForm(false);
                                setEditingProduct(null);
                                loadProducts();
                            }}
                            onCancel={() => {
                                setShowAddForm(false);
                                setEditingProduct(null);
                            }}
                        />
                    </div>
                </div>
            )}
        </div>
    );
};

export default InventoryPage;

# TREE_FILE_PATH: ./src\pages\pos\POSPage.tsx
import React, { useState, useEffect } from 'react';
import { Product, Transaction, PaymentMethod } from '../../types';
import { productOperations, transactionOperations, cashRegisterOperations } from '../../lib/database';
import Cart from '../../components/pos/Cart';
import ProductsGrid from '../../components/pos/ProductsGrid';
import CheckoutModal from '../../components/pos/CheckoutModal';
import SearchBar from '../../components/common/SearchBar';
import { useAuth } from '../../context/AuthContext';

interface CartItem {
    product: Product;
    quantity: number;
}


const CATEGORIES = ['Wines', 'Beers', 'Spirits', 'Food', 'Others'];

const POSPage = () => {
    const [products, setProducts] = useState<Product[]>([]);
    const [cartItems, setCartItems] = useState<CartItem[]>([]);
    const [selectedCategory, setSelectedCategory] = useState<string | null>(null);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);
    const [showCheckout, setShowCheckout] = useState(false);
    const [searchTerm, setSearchTerm] = useState('');
    const [discount, setDiscount] = useState(0);
    const { user } = useAuth();


    useEffect(() => {
        loadProducts();
    }, []);

    const loadProducts = async () => {
        try {
            setIsLoading(true);
            const allProducts = await productOperations.getAll();
            setProducts(allProducts.filter(p => p.isActive));  // Modificar esta l√≠nea
        } catch (err) {
            setError('Error loading products');
        } finally {
            setIsLoading(false);
        }
    };

    const filteredProducts = products.filter(product => {
        const searchLower = searchTerm.toLowerCase();
        return product.name.toLowerCase().includes(searchLower) ||
            (product.barcode && product.barcode.toLowerCase().includes(searchLower));
    });

    const handleProductSelect = (product: Product) => {
        setCartItems(prev => {
            const existing = prev.find(item => item.product.id === product.id);
            if (existing) {
                return prev.map(item =>
                    item.product.id === product.id
                        ? { ...item, quantity: item.quantity + 1 }
                        : item
                );
            }
            return [...prev, { product, quantity: 1 }];
        });
    };

    const handleUpdateQuantity = (productId: number, newQuantity: number) => {
        if (newQuantity <= 0) {
            handleRemoveItem(productId);
            return;
        }

        setCartItems(prev =>
            prev.map(item =>
                item.product.id === productId
                    ? { ...item, quantity: newQuantity }
                    : item
            )
        );
    };

    const handleRemoveItem = (productId: number) => {
        setCartItems(prev => prev.filter(item => item.product.id !== productId));
    };

    const handleCheckout = async (paymentMethod: PaymentMethod, customerName: string, discount: number) => {
        try {
            const currentRegister = await cashRegisterOperations.getCurrent();
            if (!currentRegister) {
                alert('Please open the register first');
                return;
            }

            // Calcular total con descuento
            const subtotal = cartItems.reduce(
                (sum, item) => sum + item.product.price * item.quantity,
                0
            );
            const total = Math.max(0, subtotal - discount);

            // Crear transacci√≥n
            if (!user) {
                throw new Error('User not authenticated');
            }
            const transaction: Omit<Transaction, 'id'> = {
                amount: total,
                discount: discount,
                type: paymentMethod,
                createdAt: new Date(),
                userId: user.id,
                registerId: currentRegister.id,
                customerName: customerName || undefined,
                status: 'active'
            };

            await transactionOperations.create(transaction);

            // Actualizar stock
            for (const item of cartItems) {
                await productOperations.update(item.product.id, {
                    stock: item.product.stock - item.quantity
                });
            }

            setCartItems([]);
            loadProducts();
            setShowCheckout(false);

            alert('Sale completed successfully!');
        } catch (err) {
            setError('Error processing sale');
        }
    };

    if (isLoading) return <div>Loading...</div>;

    return (
        <div className="h-[calc(100vh-4rem)] flex gap-4">
            <div className="flex-1 flex flex-col overflow-hidden">
                <div className="mb-4 flex gap-2 overflow-x-auto py-2">
                    <button
                        onClick={() => setSelectedCategory(null)}
                        className={`px-4 py-2 rounded-lg whitespace-nowrap ${selectedCategory === null
                            ? 'bg-blue-600 text-white'
                            : 'bg-gray-100 text-gray-800'
                            }`}
                    >
                        All
                    </button>
                    {CATEGORIES.map(category => (
                        <button
                            key={category}
                            onClick={() => setSelectedCategory(category)}
                            className={`px-4 py-2 rounded-lg whitespace-nowrap ${selectedCategory === category
                                ? 'bg-blue-600 text-white'
                                : 'bg-gray-100 text-gray-800'
                                }`}
                        >
                            {category}
                        </button>
                    ))}
                </div>

                <div className="mb-4 flex gap-2">
                    <div className="flex-1">
                        <SearchBar
                            value={searchTerm}
                            onChange={setSearchTerm}
                            placeholder="Search by name or barcode..."
                        />
                    </div>
                    <div className="flex space-x-2 overflow-x-auto py-2">
                        <button
                            onClick={() => setSelectedCategory(null)}
                            className={`px-4 py-2 rounded-lg whitespace-nowrap ${selectedCategory === null
                                ? 'bg-blue-600 text-white'
                                : 'bg-gray-100 text-gray-800'
                                }`}
                        >
                            All
                        </button>
                        {CATEGORIES.map(category => (
                            <button
                                key={category}
                                onClick={() => setSelectedCategory(category)}
                                className={`px-4 py-2 rounded-lg whitespace-nowrap ${selectedCategory === category
                                    ? 'bg-blue-600 text-white'
                                    : 'bg-gray-100 text-gray-800'
                                    }`}
                            >
                                {category}
                            </button>
                        ))}
                    </div>
                </div>

                <div className="flex-1 overflow-auto pb-4">
                    <ProductsGrid
                        products={filteredProducts}
                        onProductSelect={handleProductSelect}
                        selectedCategory={selectedCategory}
                    />
                </div>
            </div>

            <div className="w-96">
                <Cart
                    items={cartItems}
                    onUpdateQuantity={handleUpdateQuantity}
                    onRemoveItem={handleRemoveItem}
                    onCheckout={() => setShowCheckout(true)}
                    onClearCart={() => setCartItems([])}
                    discount={discount}
                    onDiscountChange={setDiscount}
                />
            </div>

            {showCheckout && (
                <CheckoutModal
                    total={cartItems.reduce(
                        (sum, item) => sum + item.product.price * item.quantity,
                        0
                    )}
                    discount={discount}  // Nuevo prop
                    onComplete={(paymentMethod, customerName) =>
                        handleCheckout(paymentMethod, customerName, discount)
                    }
                    onCancel={() => setShowCheckout(false)}
                />
            )}

            {error && (
                <div className="fixed bottom-4 right-4 bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded">
                    {error}
                </div>
            )}
        </div>
    );
};

export default POSPage;

# TREE_FILE_PATH: ./src\pages\register\RegisterControl.tsx
// src/pages/register/RegisterControl.tsx
import React, { useState, useEffect } from 'react';
import { Transaction, CashRegister, PaymentMethod } from '../../types';
import { cashRegisterOperations, transactionOperations } from '../../lib/database';
import SalesSummary from '../../components/register/SalesSummary';
import { saveAs } from 'file-saver';
import { useAuth } from '../../context/AuthContext';
import { config } from '../../config';


const RegisterControl = () => {
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);
    const [currentRegister, setCurrentRegister] = useState<CashRegister | null>(null);
    const [transactions, setTransactions] = useState<Transaction[]>([]);
    const [initialAmount, setInitialAmount] = useState('');
    const [finalAmount, setFinalAmount] = useState('');
    const { user } = useAuth();

    useEffect(() => {
        checkRegisterStatus();
    }, []);

    const checkRegisterStatus = async () => {
        try {
            setIsLoading(true);
            const registers = await cashRegisterOperations.getCurrent(user?.id);
            setCurrentRegister(registers || null);

            if (registers) {
                // Obtener solo las transacciones del registro actual y del usuario actual
                const registerTransactions = await transactionOperations.getAll();
                const filteredTransactions = registerTransactions.filter(transaction =>
                    transaction.userId === user?.id &&
                    transaction.createdAt >= registers.openedAt &&
                    (!registers.closedAt || transaction.createdAt <= registers.closedAt)
                );
                setTransactions(filteredTransactions);
            } else {
                setTransactions([]);
            }
        } catch (err) {
            setError('Error checking register status');
        } finally {
            setIsLoading(false);
        }
    };

    const handleOpenRegister = async (e: React.FormEvent) => {
        e.preventDefault();
        try {
            const amount = parseFloat(initialAmount);
            if (isNaN(amount) || amount < 0) {
                setError('Please enter a valid amount');
                return;
            }

            if (!user) {
                setError('User not authenticated');
                return;
            }

            const register: Omit<CashRegister, 'id'> = {
                status: 'open',
                openedAt: new Date(),
                initialAmount: amount,
                userId: user.id,
                deviceId: localStorage.getItem('deviceId') || 'unknown'
            };

            await cashRegisterOperations.create(register);
            setInitialAmount('');
            checkRegisterStatus();
        } catch (err) {
            setError('Error opening register');
        }
    };

    const handleCloseRegister = async (e: React.FormEvent) => {
        e.preventDefault();
        if (!currentRegister) return;

        try {
            const amount = parseFloat(finalAmount);
            if (isNaN(amount) || amount < 0) {
                setError('Please enter a valid amount');
                return;
            }

            console.log('Cerrando caja...', currentRegister.id);

            // Actualizar estado de la caja
            await cashRegisterOperations.update(currentRegister.id, {
                status: 'closed',
                closedAt: new Date(),
                finalAmount: amount
            });

            console.log('Caja cerrada, generando reporte...');
            await generateReport();

            console.log('Limpiando estado...');
            setFinalAmount('');
            setTransactions([]);
            await checkRegisterStatus();

            console.log('Proceso completado');
        } catch (err) {
            console.error('Error al cerrar caja:', err);
            setError('Error closing register');
        }
    };

    const generateReport = async () => {
        if (!currentRegister || !user) return;

        const totalSales = transactions.reduce((sum, t) => sum + t.amount, 0);
        const totalDiscounts = transactions.reduce((sum, t) => sum + t.discount, 0);
        const expectedAmount = currentRegister.initialAmount + totalSales;
        const difference = parseFloat(finalAmount) - expectedAmount;

        const rows = [
            ['Register Report'],
            ['User', user.name],
            ['Date', new Date().toLocaleDateString()],
            ['Open Time', currentRegister.openedAt.toLocaleString()],
            ['Close Time', new Date().toLocaleString()],
            ['Initial Amount', `$${currentRegister.initialAmount.toFixed(2)}`],
            ['Total Sales', `$${totalSales.toFixed(2)}`],
            ['Total Discounts', `$${totalDiscounts.toFixed(2)}`],  // Nueva l√≠nea
            ['Final Amount', `$${finalAmount}`],
            ['Expected Amount', `$${expectedAmount.toFixed(2)}`],
            ['Difference', `$${difference.toFixed(2)}`],
            [''],
            ['Transaction Details'],
            ['Time', 'Amount', 'Discount', 'Payment Method', 'Customer']  // Agregado "Discount"
        ];

        transactions.forEach(t => {
            rows.push([
                t.createdAt.toLocaleString(),
                `$${t.amount.toFixed(2)}`,
                `$${t.discount.toFixed(2)}`,  // Nueva columna
                t.type,
                t.customerName || '-'
            ]);
        });

        const csvContent = rows.map(row =>
            row.map(cell =>
                typeof cell === 'string' && cell.includes(',')
                    ? `"${cell}"`
                    : cell
            ).join(',')
        ).join('\n');

        const blob = new Blob(['\ufeff' + csvContent], {
            type: 'text/csv;charset=utf-8'
        });

        saveAs(blob, `register-report-${new Date().toISOString().split('T')[0]}.csv`);
    };

    const handleCancelTransaction = async (transactionId: number) => {
        try {
            await transactionOperations.cancelTransaction(transactionId);
            await checkRegisterStatus();
        } catch (err) {
            setError('Error cancelling transaction');
            console.error('Error:', err);
        }
    };

    if (isLoading) return <div>Loading...</div>;

    return (
        <div className="max-w-7xl mx-auto space-y-6">
            <h1 className="text-2xl font-bold">Register Control</h1>

            {error && (
                <div className="bg-red-50 text-red-600 p-4 rounded-md">
                    {error}
                </div>
            )}

            {currentRegister ? (
                <div className="space-y-6">
                    <div className="bg-white p-6 rounded-lg shadow">
                        <div className="flex items-center justify-between mb-6">
                            <div>
                                <h2 className="text-lg font-medium">Current Register Session</h2>
                                <p className="text-sm text-gray-500">
                                    Opened: {currentRegister.openedAt.toLocaleString()}
                                </p>
                            </div>
                            <div>
                                <button
                                    onClick={() => generateReport()}
                                    className="mr-4 text-blue-600 hover:text-blue-800"
                                >
                                    Download Report
                                </button>
                            </div>
                        </div>

                        <SalesSummary
                            transactions={transactions}
                            initialAmount={currentRegister.initialAmount}
                            currentRegister={currentRegister}
                            onCancelTransaction={handleCancelTransaction}
                        />

                        <form onSubmit={handleCloseRegister} className="mt-6">
                            <div className="max-w-xs">
                                <label className="block text-sm font-medium text-gray-700">
                                    Final Amount in Register
                                </label>
                                <input
                                    type="number"
                                    value={finalAmount}
                                    onChange={(e) => setFinalAmount(e.target.value)}
                                    step="0.01"
                                    min="0"
                                    required
                                    className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
                                />
                            </div>
                            <button
                                type="submit"
                                className="mt-4 bg-red-600 text-white px-4 py-2 rounded-md hover:bg-red-700"
                            >
                                Close Register
                            </button>
                        </form>
                    </div>
                </div>
            ) : (
                <form onSubmit={handleOpenRegister} className="bg-white p-6 rounded-lg shadow max-w-md">
                    <h2 className="text-lg font-medium mb-4">Open Register</h2>
                    <div>
                        <label className="block text-sm font-medium text-gray-700">
                            Initial Amount in Register
                        </label>
                        <input
                            type="number"
                            value={initialAmount}
                            onChange={(e) => setInitialAmount(e.target.value)}
                            step="0.01"
                            min="0"
                            required
                            className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
                        />
                    </div>
                    <button
                        type="submit"
                        className="mt-4 bg-green-600 text-white px-4 py-2 rounded-md hover:bg-green-700"
                    >
                        Open Register
                    </button>
                </form>
            )}
        </div>
    );
};

export default RegisterControl;

# TREE_FILE_PATH: ./src\types\index.ts
export type PaymentMethod = 'cash' | 'card' | 'transfer';
export type RegisterStatus = 'open' | 'closed';

export interface Product {
    id: number;
    name: string;
    price: number;
    stock: number;
    category?: string;
    imageUrl?: string;
    barcode?: string;
    minStock?: number;
    createdAt: Date;
    updatedAt: Date;
    supplierId?: number;
    cost: number;
    isActive: boolean;
}

export interface Transaction {
    id: number;
    amount: number;
    discount: number;
    type: PaymentMethod;
    createdAt: Date;
    customerName?: string;
    userId: string;
    registerId: number;
    status: 'active' | 'cancelled';
}

export interface CashRegister {
    id: number;
    status: RegisterStatus;
    initialAmount: number;
    finalAmount?: number;
    openedAt: Date;
    closedAt?: Date;
    deviceId: string;
    userId: string;
}

// Tipos para sincronizaci√≥n
export type SyncEntityType = 'product' | 'transaction' | 'cashRegister';
export type SyncOperationType = 'create' | 'update' | 'delete';
export type SyncStatus = 'pending' | 'completed' | 'failed';

# TREE_FILE_PATH: ./src\types\service-worker.d.ts
/// <reference lib="webworker" />

declare const self: ServiceWorkerGlobalScope;

interface WorkboxManifest {
    revision: string;
    url: string;
}

declare global {
    interface ServiceWorkerGlobalScope {
        __WB_MANIFEST: Array<WorkboxManifest>;
    }
}

export { };

# TREE_FILE_PATH: ./src\types\sync.ts
export interface SyncOperation {
    id: string;
    timestamp: number;
    type: 'create' | 'update' | 'delete';
    entity: 'product' | 'transaction' | 'cashRegister';
    data: string;  // JSON serializado
    deviceId: string;
    status: 'pending' | 'completed' | 'failed';
}

export interface SyncRequest {
    operations: SyncOperation[];
    lastSyncTimestamp: number;
    deviceId: string;
}

export interface SyncResponse {
    success: boolean;
    operations: SyncOperation[];
    lastSyncTimestamp: number;
    error?: string;
}